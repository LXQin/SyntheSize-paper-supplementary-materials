---
title: "CaseStudy"
author: "Yunhui Qi"
date: '2022-10-24'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r, import packages}
library(ggplot2)
library(tidyverse)
library(DANA)
library(cowplot)
library(ggpubr)
library(ggsci)
library(cowplot)
library(reshape2)
library(glmnet)
library(e1071)
library(caret)
library(randomForest)
library(xgboost)
library(ROCR)
library(class)
library(tidyverse)
```


```{r, set file source location as working directory}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

```{r, classification functions}
######### For all classifiers: ####
# train_data, test_data are data frames with samples in rows.
# train_labels, test_labels are numbers with 0 for the first level, 1 for the second level.
# require train_data and test_data to be scaled and centered for successful genes
# LOGIS: 5 folds cv to choose penalty
# SVM: default
# KNN: choose k = 20, does not provides probabilities, auc = 0
# RF: ntree = 100
# XGB: nrounds = 25
# eval_classifier: evaluation is through 5 folds cv for each candidate sample size and each draw.

# Function for Logistic Regression with Lasso penalty
LOGIS <- function(train_data, train_labels, test_data, test_labels) {
  model <- cv.glmnet(as.matrix(train_data), as.factor(train_labels),
                     alpha = 0, family = "binomial", nfolds = 5)
  predictions <- predict(model, newx = as.matrix(test_data),
                          s = "lambda.min", type = "response")
  accuracy <- sum((predictions > 0.5) == test_labels) / length(test_labels)
  prediction_obj <- prediction(predictions, test_labels)
  auc <- performance(prediction_obj, measure = "auc")@y.values[[1]]
  res <- c(accuracy, auc)
  names(res) <- c("accuracy","auc")
  return(res)
}

# Function for SVM
SVM <- function(train_data, train_labels, test_data, test_labels) {
  model <- svm(as.factor(train_labels) ~ ., data = train_data,
               probability = TRUE)
  predictions <- predict(model, test_data, probability=TRUE)
  predictions <- attr(predictions, "probabilities")[,2]
  accuracy <- sum((predictions > 0.5) == test_labels) / length(test_labels)
  prediction_obj <- prediction(predictions, test_labels)
  auc <- performance(prediction_obj, measure = "auc")@y.values[[1]]
  res <- c(accuracy, auc)
  names(res) <- c("accuracy","auc")
  return(res)
}

# Function for k-Nearest Neighbors (k-NN)
KNN <- function(train_data, train_labels, test_data, test_labels) {
  model <- knn(train = train_data, test = test_data,
               cl = as.factor(train_labels), k = 20)
  accuracy <- sum(model == test_labels) / length(test_labels)
  auc <- 0
  res <- c(accuracy, auc)
  names(res) <- c("accuracy","auc")
  return(res)
}

# Function for Random Forest
RF <- function(train_data, train_labels, test_data, test_labels) {
  model <- randomForest(x = train_data, y = as.factor(train_labels),
                        xtest = test_data, ytest = as.factor(test_labels),
                        ntree = 100, keep.forest = TRUE) 
  predictions <- predict(model, test_data, type="prob")
  accuracy <- sum(predict(model, test_data) == test_labels) / length(test_labels)
  prediction_obj <- prediction(predictions[,2], test_labels)
  auc <- performance(prediction_obj, measure = "auc")@y.values[[1]]
  res <- c(accuracy, auc)
  names(res) <- c("accuracy","auc")
  return(res)
}

# Function for XGBoost
XGB <- function(train_data, train_labels, test_data, test_labels) {
  model <- xgboost(data = as.matrix(train_data), label = train_labels,
                   nrounds = 25, verbose = 0, 
                   objective = "binary:logistic")

  predictions <- predict(model, as.matrix(test_data))
  accuracy <- sum((predictions > 0.5) == test_labels) / length(test_labels)
  prediction_obj <- prediction(predictions, test_labels)
  auc <- performance(prediction_obj, measure = "auc")@y.values[[1]]
  res <- c(accuracy, auc)
  names(res) <- c("accuracy","auc")
  return(res)
}

eval_classifier <- function(whole_generated, whole_groups = NULL,
                            n_candidate, n_draw = 5, log = TRUE){
  # This function perform multiple classification algorithm on the candidate sample size
  # @params: whole_generated - generated data matrix 
  # @params: whole_groups - vector containing the group information of samples
  # @params: log - whether the data is log2 transformed
  # @params: n_candidate - the candidate total sample sizes, half of them for each group label
  # @params: n_draw - the number of times drawing n_candidate from the whole_generated
  
  if(!log){
    whole_generated <- log2(whole_generated + 1)
  }
  g1 <- unique(whole_groups)[1]
  g2 <- unique(whole_groups)[2]
  dat_g1 <- whole_generated[whole_groups == g1, ]
  dat_g2 <- whole_generated[whole_groups == g2, ]
  
 # if(failure == "remove"){
 #    dat_g1 <- dat_g1[, apply(dat_g1, 2, sd) != 0]
 #    dat_g2 <- dat_g2[, apply(dat_g2, 2, sd) != 0]
 # }
  res <- data.frame(total_size = numeric(0), draw = numeric(0), 
                    method = character(0), accuracy = numeric(0), 
                    auc = numeric(0))

  for (n_index in 1:length(n_candidate)) {
    n <- n_candidate[n_index]
    cat(n_index)
    for (draw in 1:n_draw) {
      cat(draw)
      dat_g1_candidate <- dat_g1[sample(1:nrow(dat_g1), n/2, replace = F),]
      dat_g2_candidate <- dat_g2[sample(1:nrow(dat_g2), n/2, replace = F),]
      dat_candidate <- rbind(dat_g1_candidate, dat_g2_candidate)
      groups_candidate <- rep(c(g1, g2), each = n/2)

      num_folds <- 5  
      df_acc <- data.frame(LOGIS = numeric(0), SVM = numeric(0), 
                           KNN = numeric(0), RF = numeric(0),
                           XGB = numeric(0))
      df_auc <- df_acc
      
      # Create stratified folds for cross-validation
      folds <- createFolds(groups_candidate, k = num_folds, 
                           list = TRUE, returnTrain = FALSE)
      # Iterate through the folds to get test and train data
      for (fold_index in 1:num_folds) {
        # Get the indices of samples in the current test fold
        test_indices <- folds[[fold_index]]
      
        # Get the test data and labels using the test indices
        test_data <- dat_candidate[test_indices,]
        test_labels <- ifelse(groups_candidate[test_indices] == g1, 0, 1)
        
        # Get the indices of samples in the training fold
        train_indices <- setdiff(1:nrow(dat_candidate), test_indices)
        
        # Get the training data and labels using the training indices
        train_data <- dat_candidate[train_indices,]
        train_labels <- ifelse(groups_candidate[train_indices] == g1, 0, 1)
        
        # Scaling for successful features
        train_data[,apply(train_data, 2, sd) != 0] <- scale(train_data[,apply(train_data, 2, sd) != 0])
        test_data[,apply(test_data, 2, sd) != 0] <- scale(test_data[,apply(test_data, 2, sd) != 0])
        
        # Classification
        fit_logis <- LOGIS(train_data, train_labels, test_data, test_labels)
        fit_svm <- SVM(train_data, train_labels, test_data, test_labels)
        fit_knn <- KNN(train_data, train_labels, test_data, test_labels)
        fit_rf <- RF(train_data, train_labels, test_data, test_labels)
        fit_xgb <- XGB(train_data, train_labels, test_data, test_labels)
        
        df_acc[fold_index,] <- c(fit_logis["accuracy"], fit_svm["accuracy"],
                                 fit_knn["accuracy"], fit_rf["accuracy"],
                                 fit_xgb["accuracy"])
        df_auc[fold_index,] <- c(fit_logis["auc"], fit_svm["auc"],
                                 fit_knn["auc"], fit_rf["auc"],
                                 fit_xgb["auc"])    
     
      }
      res <- rbind(res, data.frame(total_size = n,
                                   draw = draw,
                                   method = c("LOGIS", "SVM", "KNN",
                                              "RF","XGB"),
                                   accuracy = apply(df_acc,2,mean),
                                   auc = apply(df_auc, 2, mean)))
  }
  }
       return(res)
}

vis_classifier <- function(metric_generated, metric_real, n_target, save_root){

  mean_acc_generated <- metric_generated %>% group_by(total_size, method) %>%   summarise(accuracy = mean(accuracy))
  # mean_acc_generated <- metric_generated
  mean_acc_generated$n <- mean_acc_generated$total_size
  
  mean_auc_generated <- metric_generated %>% group_by(total_size, method) %>%   summarise(accuracy = mean(auc))
  # mean_auc_generated <- metric_generated
  mean_auc_generated$n <- mean_auc_generated$total_size
  
  mean_acc_real <- metric_real %>% group_by(total_size, method) %>% summarise(accuracy = mean(accuracy))
  # mean_acc_real <- metric_real
  mean_acc_real$n <- mean_acc_real$total_size
  
  mean_auc_real <- metric_real %>% group_by(total_size, method) %>% summarise(accuracy = mean(auc))
  # mean_auc_real <- metric_real
  mean_auc_real$n <- mean_auc_real$total_size
  
  acc_graphs <- list()
  auc_graphs <- list()
  for (classifier in unique(metric_real$method)) {
    cat(classifier)
    ss_est_real <- curve_fit(acc_table = mean_acc_real[mean_acc_real$method == classifier,], n_target = n_target, annotation = c("Accuracy", paste(classifier,": TCGA", sep = "")))
    ss_est_generated <- curve_fit(acc_table = mean_acc_generated[mean_acc_generated$method == classifier,],  n_target = n_target, annotation = c("Accuracy", paste(classifier,": Generated", sep ="")))
    acc_graphs <- append(acc_graphs, list(ss_est_real$graph+ylim(0.5,0.85)))
    acc_graphs <- append(acc_graphs, list(ss_est_generated$graph+ylim(0.5,0.85)))
    if(classifier != "KNN"){
      ss_est_real <- curve_fit(acc_table = mean_auc_real[mean_auc_real$method == classifier,], n_target = n_target, annotation = c("AUC", paste(classifier,": TCGA", sep = "")))
      ss_est_generated <- curve_fit(acc_table = mean_auc_generated[mean_auc_generated$method == classifier,],  n_target = n_target, annotation = c("AUC", paste(classifier,": Generated", sep ="")))
      auc_graphs <- append(auc_graphs, list(ss_est_real$graph+ylim(0.72,0.9)))
      auc_graphs <- append(auc_graphs, list(ss_est_generated$graph+ylim(0.72,0.9)))
    }
  }
  pdf(file = paste(save_root,"accuracy_curve_fit.pdf", sep = ""), 
      width = 6, height = 15)
  print(ggarrange(acc_graphs[[1]], acc_graphs[[2]],
                  acc_graphs[[3]], acc_graphs[[4]],
                  acc_graphs[[5]], acc_graphs[[6]],
                  acc_graphs[[7]], acc_graphs[[8]],
                  acc_graphs[[9]], acc_graphs[[10]],
                  nrow = 5, ncol = 2, common.legend = T, legend = "bottom"))
  dev.off()
  pdf(file = paste(save_root,"auc_curve_fit.pdf", sep = ""), 
      width = 6, height = 15)
  print(ggarrange(auc_graphs[[1]], auc_graphs[[2]],
                  auc_graphs[[3]], auc_graphs[[4]],
                  auc_graphs[[5]], auc_graphs[[6]],
                  auc_graphs[[7]], auc_graphs[[8]],
                  nrow = 4, ncol = 2, common.legend = T, legend = "bottom"))
  dev.off()
}
vis_classifier_single <- function(metric_generated, n_target, save_root){

  mean_acc_generated <- metric_generated %>% group_by(total_size, method) %>%   summarise(accuracy = mean(accuracy))
  # mean_acc_generated <- metric_generated 
  mean_acc_generated$n <- mean_acc_generated$total_size
  
  mean_auc_generated <- metric_generated %>% group_by(total_size, method) %>%   summarise(accuracy = mean(auc))
  # mean_auc_generated <- metric_generated 
  mean_auc_generated$n <- mean_auc_generated$total_size
  
  acc_graphs <- list()
  auc_graphs <- list()
  for (classifier in unique(metric_generated$method)) {
    ss_est_generated <- curve_fit(acc_table = mean_acc_generated[mean_acc_generated$method == classifier,],  n_target = n_target, annotation = c("Accuracy", classifier))
    acc_graphs <- append(acc_graphs, list(ss_est_generated$graph))
    if(classifier != "KNN"){
      ss_est_generated <- curve_fit(acc_table = mean_auc_generated[mean_auc_generated$method == classifier,],  n_target = n_target, annotation = c("AUC", classifier))
      auc_graphs <- append(auc_graphs, list(ss_est_generated$graph))
    }
  }
  pdf(file = paste(save_root,"acc_auc_curve_fit.pdf", sep = ""),
      width = 8, height = 11)
  print(ggarrange(acc_graphs[[1]], auc_graphs[[1]],
                  acc_graphs[[2]], auc_graphs[[2]],
                  acc_graphs[[3]], auc_graphs[[3]], 
                  acc_graphs[[4]], auc_graphs[[4]],
                  acc_graphs[[5]],
                  nrow = 5, ncol = 2, common.legend = T, legend = "bottom"))
  dev.off()
}
```


```{r, other functions}
heatmap_eval <-  function(dat1, dat2 = NULL, main){
  # This function plot the heatmap of data matrix dat_combine
  # @params: dat_combine - the log2 data matrix with samples in rows, features in columns
  # @params: main - the title for the heatmap
  # @params: log - whether your dat_combine is log2 transformed
  if(is.null(dat2)){
    dat_combine = dat1
    dat <- data.frame(column = rep(1:ncol(dat_combine), rep(nrow(dat_combine), ncol(dat_combine))),
                   row = rep(1:nrow(dat_combine), ncol(dat_combine)),
                   value = (c(as.matrix(dat_combine))))
    p_heat <- ggplot(data = dat, aes(x = column, y = row, fill = value))+
    geom_tile()+
    theme_bw()+
    labs(title = main, x = "Genes", y = "Samples")+
    scale_fill_gradient(limits = c(0, 35))
  }
  else{
    dat11 <- data.frame(column = rep(1:ncol(dat1), rep(nrow(dat1), ncol(dat1))),
                   row = rep(1:nrow(dat1), ncol(dat1)),
                   value = (c(as.matrix(dat1))))
    dat22 <- data.frame(column = rep(1:ncol(dat2), rep(nrow(dat2), ncol(dat2))),
                   row = rep(1:nrow(dat2), ncol(dat2)),
                   value = (c(as.matrix(dat2))))
    dat_combine = rbind(dat11,dat22)
    dat_combine$type = factor(rep(c("Real", "Generated"), c(nrow(dat11), nrow(dat22))), levels = c("Real","Generated"))
    p_heat <- ggplot(data = dat_combine, aes(x = column, y = row, fill = value))+
      geom_tile(show.legend = F)+
      facet_wrap(vars(type))+
      theme_bw()+
      labs(x = "Genes", y = "Samples")+
      # scale_fill_gradientn(colors = hcl.colors(20, "RdYlGn")) +
      theme(
        strip.text = element_text(face = "bold", size = rel(0.8)),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black", fill = NA),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank())
  }
  return(p_heat)
}
UMAP_eval <- function(dat_combine, datatype = NULL, groups = NULL, log = TRUE, failure= c("replace", "remove"), legend_pos = "top"){
  # This function perform UMAP dimension reduction to real and generated combined dataset 
  # and check whether the main variation lies between real and generated samples
  # @params: dat_combine - data matrix with samples in row, features in col, first N samples are real, second N samples are generated
  # @params: groups - groups information, samples from different groups are represented by different point shape
  # @params: log - whether the data are log2 transformed
  # @params: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  if(!log){
    dat_combine <- log2(dat_combine+1)
  }
  if(is.null(datatype)){
    datatype = rep(c("Real","Generated"), rep(nrow(dat_combine)/2, 2))
  }
  # dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  # dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  dat_real <- dat_combine[datatype == "Real", ]
  dat_generated <- dat_combine[datatype == "Generated", ]
  
 if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  else if(failure == "replace"){
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  if(length(groups) == 0.5*nrow(dat_combine)){
      groups_combine <- c(groups, groups)
      groups_real <-  groups
      groups_generated <-  groups
    }
  else{
      groups_combine <- groups
      groups_real <- groups_combine[datatype == "Real"]
      groups_generated <- groups_combine[datatype == "Generated"]
  }
  mat <- as.matrix(dat_combine)

  UMAP_fit = umap::umap(mat)
  UMAP_df = UMAP_fit$layout %>% 
             as.data.frame() %>%
             dplyr::rename(UMAP1 = "V1", UMAP2 = "V2") %>%
             mutate(ID = row_number())
  if(is.null(groups)){
    factor_df = data.frame(datatype = datatype) %>% mutate(ID=row_number())
    plot_df = UMAP_df %>% inner_join(factor_df, by="ID")
    p_umap = plot_df %>% ggplot(aes(x = UMAP1, y = UMAP2, 
                                    color = datatype))+
                          geom_point()+
                          theme(legend.position="bottom")
  }
  else{
    print("works")
    factor_df = data.frame(groups = groups_combine, datatype = datatype) %>% mutate(ID=row_number())
    plot_df = UMAP_df %>% inner_join(factor_df, by="ID")
    p_umap <- plot_df %>% ggplot(aes(x = UMAP1, y = UMAP2, 
                                     color = datatype, shape = groups))+
                          geom_point()+
                          labs(color = "Datatype", shape = "Groups")+
                          theme_bw()+
                          scale_color_rickandmorty()+
                          theme(
                            strip.text = element_text(face = "bold", size = rel(0.8)),
                            strip.background = element_blank(),
                            panel.border = element_rect(colour = "black", fill = NA),
                            axis.text.x = element_blank(),
                            axis.ticks.x = element_blank(),
                            axis.ticks.y = element_blank(),
                            axis.text.y = element_blank(),
                            panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank(),
                            axis.line = element_blank())+
      guides(color = guide_legend(order=1, nrow=2),
             shape = guide_legend(order=2, nrow=2))+
                        theme(legend.position=legend_pos,
                                  legend.title = element_text(size=10),
                                  legend.text = element_text(size=10) )
                            
  }
  return(list(plot_df = plot_df, p_umap = p_umap))
}
eval_cluster <- function(whole_generated, whole_groups = NULL, 
                         n_candidate, n_draw = 5, log = TRUE){
  # This function perform the clustering on the candidate sample size
  # @params: whole_generated - generated data matrix 
  # @params: whole_groups - vector containing the group information of samples
  # @params: log - whether the data is log2 transformed
  # @params: n_candidate - the candidate total sample sizes, half of them for each group label
  # @params: n_draw - the number of times drawing n_candidate from the whole_generated
  # @return: if groups are given, return ARI index, otherwise, return 1-ARI(datatype, clusters)
  
  if(!log){
    whole_generated <- log2(whole_generated + 1)
  }
  g1 <- unique(whole_groups)[1]
  g2 <- unique(whole_groups)[2]
  dat_g1 <- whole_generated[whole_groups == g1, ]
  dat_g2 <- whole_generated[whole_groups == g2, ]
  
 # if(failure == "remove"){
 #    dat_g1 <- dat_g1[, apply(dat_g1, 2, sd) != 0]
 #    dat_g2 <- dat_g2[, apply(dat_g2, 2, sd) != 0]
 # }
  no_clusters <- 2
  res <- data.frame(total_size = rep(NA, length(n_candidate)*n_draw),
                    draw = rep(NA, length(n_candidate)*n_draw),
                    ARI = rep(NA, length(n_candidate)*n_draw))
  res_km <- res
  for (n_index in 1:length(n_candidate)) {
    n <- n_candidate[n_index]
    cat(n)
    for (draw in 1:n_draw) {
      dat_g1_candidate <- dat_g1[sample(1:nrow(dat_g1), n/2, replace = F),]
      dat_g2_candidate <- dat_g2[sample(1:nrow(dat_g2), n/2, replace = F),]
      dat_candidate <- rbind(dat_g1_candidate, dat_g2_candidate)
      groups_candidate <- rep(c(g1, g2), each = n/2)
      # d <- dist(dat_candidate, method = "euclidean") 
      # fit <- hclust(d, method = "ward.D2")
      # clusters <- cutree(fit, k = no_clusters)
      # res[(draw + (n_index-1)*n_draw), c("total_size", "draw", "ARI")] <- 
      #   c(n, draw, round(aricode::ARI(groups_candidate, clusters),4))
      kmeans_result <- kmeans(dat_candidate, centers = no_clusters, nstart = 20)
      res_km[(draw + (n_index-1)*n_draw), c("total_size", "draw", "ARI")] <- 
        c(n, draw, round(aricode::ARI(groups_candidate, kmeans_result$cluster),4))
      }

  }
    res <- rbind(res, res_km)
    res$method <- rep(c("HC", "Kmeans"), each = length(n_candidate)*n_draw)
    return(res)
}
curve_fit <- function(acc_table, acc_target = NULL, n_target = NULL, plot = TRUE, annotation = c("Accuracy", "")){
  # This is a function fitting power law curve between accuracy and sample size
  # @params acc_table - a data frame including two columns, n and accuracy
  # @params acc_target - the target accuracy used to compute sample size requirement
  # @params n_target - the target sample size used to compute accuracy
  # @params annotation - a vector including the ylabel, and main
  # from paper: Predicting sample size required for classification performance 2012
  
  # specify model
  gradientF <- deriv3( ~(1 - a) - (b * (x^c)), c("a", "b", "c"), function(a, b, c, x) NULL)
  
  # fitting the model using nls
  m <- nls(y ~ gradientF(a, b, c, x), start = list(a = 0, b = 1, c = -0.5), 
           weights = seq(1, nrow(acc_table))/nrow(acc_table), 
           control = list(maxiter = 1000, warnOnly = TRUE),
           algorithm = "port", upper = list(a = 10, b = 10, c = -0.1), 
           lower = list(a = 0, b = 0, c=-10),
           data = data.frame(y = acc_table$accuracy, x = acc_table$n))
  
  
  # build fitted values and CI
  est <- fitted.values(m)
  if(var(est) == 0){
    cat("All estimated values are the same, cannot compute the CI")
    est_df <- data.frame(n = acc_table$n,
                         Estimated = acc_table$accuracy,
                         Predict = NA,
                         Accuracy = est,
                         Low = NA,
                         High = NA)
  }
  else{
    se_fit_est <- sqrt(apply(attr(predict(m, list(x = acc_table$n)),"gradient"), 1, function(x) sum(vcov(m)*outer(x,x))))
    est_ci <- est + outer(se_fit_est,qnorm(c(.5, .025,.975)))
    est_df <- data.frame(n = acc_table$n, 
                         Estimated = acc_table$accuracy,
                         Predict = NA,
                         Accuracy = est_ci[,1],
                         Low = est_ci[,2],
                         High = est_ci[,3])
  }
  
  # prediction and CI
  if(!is.null(acc_target)){
    cef <- coefficients(m)
    a <- cef[1]
    b <- cef[2]
    c <- cef[3]
    ss <- ((1-a-acc_target)/b)^(1/c)
  }
  if(!is.null(n_target)){
    prediction <- predict(m, list(x = n_target))
    if(var(est) != 0){
      se_fit <- sqrt(apply(attr(predict(m, list(x = n_target)),"gradient"), 1, function(x) sum(vcov(m)*outer(x,x))))
      prediction_ci <- prediction + outer(se_fit,qnorm(c(.5, .025,.975)))
      pre_df <- data.frame(n = n_target,
                         Estimated = NA, 
                         Predict = prediction_ci[,1],
                         Accuracy = prediction_ci[,1],
                         Low = prediction_ci[,2],
                         High =  prediction_ci[,3])
    }
    else{
      pre_df <- data.frame(n = n_target,
                           Estimated = NA, 
                           Predict = prediction,
                           Accuracy = prediction,
                           Low = NA,
                           High =  NA)
    } 
  }
  if(plot){
    df <- as.data.frame(rbind(est_df, pre_df))
    p <- ggplot(data = df)+
         geom_point(aes(x = n, y = Estimated, color = "Estimated"), size=2, show.legend = F)+
         geom_line(aes(x = n, y = Accuracy, color = "Fitted"), size=1, show.legend = T)+
        geom_point(aes(x = n, y = Predict, color = "Predicted"), show.legend = F)+
         labs(x = "Sample size", y = annotation[1], title = annotation[2])+
      scale_color_manual(name = "Type", breaks = c("Estimated","Fitted","Predicted"), 
                         values = c("Estimated" = "black", "Predicted" = "red", "Fitted" = "blue")) + 
        theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_blank())+
      theme_bw()+
      theme(legend.title=element_blank())+
      theme(legend.position = c(0.7, 0.28))+
      theme(plot.title = element_text(hjust = 0.5))+
      ylim(0, 1)
    if(var(est) != 0){
      p <- p + geom_ribbon(aes(x = n, ymin = Low, ymax = High), alpha = 0.2)
    }
  }
  return(list(graph = p, prediction = pre_df[,c("n", "Predict", "Low", "High")], model_fitted = m))
}

```

# Breast cancer Nature data classification
```{r, nature data, read in data}
full <- read.table(file = '../Case/transneo-diagnosis-RNAseq-rawcounts.tsv', sep = '\t', header = TRUE)
meta <- read.csv(file = "../Case/meta-data.csv", header = TRUE)


meta <- meta %>%
  filter(!is.na(pCR.RD) & Donor.ID %in% colnames(full)[-1])
RC <- full[,meta$Donor.ID]
genes <- full[,1]
group <- meta$pCR.RD
```

```{r,  nature data, descriptive analysis and generate well expressed dataset}
# imbalance grouping
ggplot(data = meta) +
  geom_histogram(aes(x = pCR.RD), stat = "Count")

# present in 99% of samples in both group: 18246 left
present <- function(gene){
  return((sum(gene[group == "pCR"] != 0) >= (0.99 * 41))
         & (sum(gene[group != "pCR"] != 0) >= (0.99 * 115)))
}
gene_present <- apply(RC, 1, present)
RC_present <- RC[gene_present,]
genes_present <- genes[gene_present]

# expression level: 12 mean gives 2722 genes
gene_means <- apply(RC_present, 1, function(x){mean(log2(x + 1))})
gene_stds <- apply(RC_present, 1, function(x){sd(log2(x + 1))})
thres_plot <- 12
ggplot(data.frame(gene_means, gene_stds)) +
  geom_point(aes(x = gene_means, y = gene_stds, color = gene_means), alpha = .4, show.legend = F)+
  scale_color_gradient(low = "#0091ff", high = "#f0650e") +
  geom_vline(xintercept = thres_plot, color = "red") +
  labs(x = "mean(log2(count))", y = "Standard Deviation", title = paste(sum(gene_means > thres_plot))) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))

RC_we <- RC_present[gene_means > thres_plot,]
genes_we <- genes_present[gene_means > thres_plot]

colnames(RC_we) <- genes_we

write.table(RC_we,
            paste("../Case/Original/", "case_pre_we_raw.csv", sep = ""),
            sep =",", row.names = F, col.names = T)

```


```{r, nature data, generate normalized dataset}
# normalize well expressed genes
RC_norms <- DANA::applyNormalization(data = as.matrix(RC_we), groups = group, method = c("UQ", "PoissonSeq"))

RC_pre_we_TC_pcr <- as.data.frame(t(RC_norms$UQ[,group == "pCR"]))
RC_pre_we_TC_pcr$groups <- "pCR"
RC_pre_we_TC_pcr$samples <-  rownames(RC_pre_we_TC_pcr)
colnames(RC_pre_we_TC_pcr) <- genes_we

RC_pre_we_TC_rd <- as.data.frame(t(RC_norms$UQ[,group != "pCR"]))
RC_pre_we_TC_rd$groups <- "RD"
RC_pre_we_TC_rd$samples <- rownames(RC_pre_we_TC_rd)
colnames(RC_pre_we_TC_rd) <- genes_we

RC_pre_we_TC <- as.data.frame(t(RC_norms$UQ))
RC_pre_we_TC$groups = group
RC_pre_we_TC$samples <- rownames(RC_pre_we_TC)
colnames(RC_pre_we_TC) = genes_we


write.table(RC_pre_we_TC,
              paste("../Case/Original/", "case_pre_we_UQ.csv", sep = ""),
              sep =",", row.names = F, col.names = T)
write.table(RC_pre_we_TC_pcr,
              paste("../Case/Original/", "case_pre_we_UQ_pcr.csv", sep = ""),
              sep =",", row.names = F, col.names = T)
write.table(RC_pre_we_TC_rd,
              paste("../Case/Original/", "case_pre_we_UQ_rd.csv", sep = ""),
              sep =",", row.names = F, col.names = T)

```


```{r, nature data, offline augment generate log2 with Gaussian noise}
# pcr 2^3*41,  rd 2^2*115
fold <- 2
counts <- case_pre_we_raw_rd[, 1:2722]
counts_log <- log2(counts + 1)
for (i_fold in 1:fold) {
  counts_log_noisy <- counts_log + matrix(rnorm(nrow(counts_log) * ncol(counts_log)), nrow = nrow(counts_log))
  counts_log <- rbind(counts_log, counts_log_noisy)
}

p_log_ori_noisy <- heatmap_eval(counts_log, main = "log2 ori (lower), noisy (upper)")

write.table(counts_log,
              paste("../Case/Original/", "case_pre_we_log2normal328_pcr.csv", sep = ""),
              sep =",", row.names = F, col.names = T)
write.table(counts_log,
              paste("../Case/Original/", "case_pre_we_log2normal460_rd.csv", sep = ""),
              sep =",", row.names = F, col.names = T)
counts_log <- rbind(counts_log_pcr, counts_log)
counts_log$groups = rep(c("pCR", "RD"), c(328,460))
write.table(counts_log,
              paste("../Case/Original/", "case_pre_we_log2normal788.csv", sep = ""),
              sep =",", row.names = F, col.names = T)
```

```{r, nature data, CVAE1-10, log2normal788, generated 250 each, quality evaluation}
generated <- read.csv("../Case/log2normal/case_pre_we_log2normal788_CVAE1-10_generated.csv", header = F)
real <- read.csv("../Case/log2normal/case_pre_we_log2normal788.csv", header = T)[c(1:41, 329:443),]
colnames(generated) <- colnames(real)
heatmap_eval(rbind(real[,1:2722], generated[,1:2722]), main = "")
accuracy <- read.csv("../Case/log2normal/accuracy_table.csv", header=T, sep="\t")
ggplot(data=accuracy, aes(x = factor(total_size), y = accuracy))+
  geom_boxplot()+
  labs(x = "Candidate total sample size", y= "Accuracy for classification")
mean_accuracy <- accuracy %>% group_by(total_size) %>% summarise(mean_accuracy = mean(accuracy))

ggplot(data = mean_accuracy, aes(x=total_size, y=mean_accuracy))+
  geom_point()+
  geom_line()

```

```{r, nature data, MAF, log2normal788, generated 500 each, quality evaluation}
generated <- read.csv("../Case/log2normal/case_pre_we_log2normal788_MAF_generated.csv", header = T)
groups_generated <- generated[, 2723]
real <- read.csv("../Case/log2normal/case_pre_we_log2normal788.csv", header = T)[c(1:41, 329:443),]
groups_real <- real$groups
real <- select_if(real, is.numeric)
colnames(generated) <- colnames(real)
generated <- generated[,1:2722]
h <- heatmap_eval(dat1 = real[,1:2722], dat2 = generated[c(1:41, 502:616),1:2722])
h
p_umap_summet <- UMAP_eval(dat_combine = rbind(real[,1:2722],
                                        generated[c(1:41, 502:616),1:2722]),
                    groups = c(groups_real,
                               groups_generated[c(1:41, 502:616)]),
                    log = TRUE, failure = "remove", legend_pos = "left")
umap_summet <- p_umap_summet$p_umap
```

```{r, nature data, MAF classification multiple classifiers}
set.seed(111)
n_candidate <- seq(100, 400, 20)
n_target <- seq(450, 500, 10)
save_root <- "../Case/log2normal/"
metric_generated <- eval_classifier(generated, groups_generated,
                                    n_candidate, n_draw = 5, log = TRUE)
write.table(metric_generated, paste(save_root, "metric_generated.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
metric_generated <- read.csv("../Case/log2normal/metric_generated.csv", header = TRUE)

vis_classifier_single(metric_generated = metric_generated,
                      n_target = n_target, 
                      save_root = save_root)
```


```{r, nature data, MAF multiple classifiers for validation purpose with smaller total sizes}
n_candidate <- seq(36, 80, 2)
n_target <- seq(85, 100, 5)
save_root <- "../Case/log2normal/"
metric_generated <- eval_classifier(generated, groups_generated,
                                    n_candidate, n_draw = 5, log = TRUE)
metric_real <- eval_classifier(real, groups_real, 
                               n_candidate, n_draw = 5, log = TRUE)
write.table(metric_generated, paste(save_root, "metric_generated_maf_smalln.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
write.table(metric_real, paste(save_root, "metric_real_maf_smalln.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
metric_generated <- read.csv("../Case/BRCASubtype/metric_generated_smalln.csv", header = TRUE)
metric_real <- read.csv("../Case/BRCASubtype/metric_real_smalln.csv", header = TRUE)
vis_classifier(metric_generated = metric_generated, 
               metric_real = metric_real,
               n_target = n_target,
               save_root = save_root)
```

```{r, nature data classification RF python}
accuracy <- read.csv("../Case/log2normal/maf_accuracy_table_more.csv", header=T, sep="\t")
accuracy$n <- accuracy$total_size
ggplot(data=accuracy, aes(x = factor(total_size), y = accuracy))+
  geom_boxplot()+
  labs(x = "Candidate total sample size", y= "Accuracy for classification")

acc_table <- accuracy %>% group_by(n) %>% summarise(accuracy = mean(accuracy))

ggplot(data = acc_table, aes(x=n, y=accuracy))+
  geom_point()+
  geom_line()
ss_est <- curve_fit(acc_table = acc_table, n_target = seq(520, 700, 20))
print(ss_est$graph)
```

```{r, F8AB}
h
ss_est$graph
```

# BRCAPRAD.csv clustering
```{r, BRCAPRAD, CVAE1-10,  generated 500 each, quality evaluation}
# read in data
generated <- read.csv("../Case/BRCAPRAD/BRCAPRAD_CVAE1-10_generated.csv", header = F)
real <- read.csv("../Case/BRCAPRAD/BRCAPRAD.csv", header = T)
groups_real <- real$groups
groups_generated <- ifelse(generated[, ncol(generated)] == 0, "BRCA", "PRAD")
real <- select_if(real, is.numeric)
real <- log2(real + 1)
generated <- generated[,1:ncol(real)]
colnames(generated) <- colnames(real)
# heatmap quality evaluation
h_types <- heatmap_eval(real[c(1:200, 1558:1758),],
             generated[c(1:200, 800:1000),], main = "")
# UMAP quality evaluation
p_umap_types <- UMAP_eval(dat_combine = rbind(real[c(1:200, 1558:1758),],
                                        generated[c(1:200, 800:1000),]),
                    groups = c(groups_real[c(1:200, 1558:1758)],
                               groups_generated[c(1:200, 800:1000)]),
                    log = TRUE, failure = "remove", legend_pos = "left")
umap_types <- p_umap_types <- p_umap_types$p_umap + theme(legend.position = "bottom") +scale_color_aaas()
ggsave("../Case/BRCAPRAD/Case_BRCAPRAD_UMAP.pdf", umap_types, height = 5, width = 4, unit = "in")
```

```{r,BRCAPRAD, CVAE1-10, multiple clustering}
# real clustering results
real_ARI <- eval_cluster(whole_generated = real,
                    whole_groups = groups_real,
                    n_candidate = seq(10, 300, 10),
                    n_draw = 50)
# write.table(real_ARI, "../Case/BRCAPRAD/ARI_real.csv",
# sep =",", row.names = F, col.names = T)
real_ARI <- read.csv("../Case/BRCAPRAD/ARI_real.csv",header=T)

mean_ARI <- real_ARI %>% group_by(method, total_size) %>% summarise(mean_ARI = mean(ARI))
HC_mean_ARI <- mean_ARI[mean_ARI$method == "HC",]
KM_mean_ARI <- mean_ARI[mean_ARI$method != "HC",]
power_real_HC <- curve_fit(acc_table = data.frame(n = HC_mean_ARI$total_size,
                                               accuracy = HC_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "HC: TCGA"))
power_real_KM <- curve_fit(acc_table = data.frame(n = KM_mean_ARI$total_size,
                                               accuracy = KM_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "Kmeans: TCGA"))

# generated clustering results
generated_ARI <- eval_cluster(whole_generated = generated,
                         whole_groups = groups_generated,
                         n_candidate = seq(10, 300, 10),
                         n_draw = 50)
# write.table(generated_ARI, "../Case/BRCAPRAD/ARI_generated.csv",
# sep =",", row.names = F, col.names = T)
generated_ARI <- read.csv("../Case/BRCAPRAD/ARI_generated.csv",header=T)
mean_ARI <- generated_ARI %>% group_by(method, total_size) %>% summarise(mean_ARI = mean(ARI))
HC_mean_ARI <- mean_ARI[mean_ARI$method == "HC",]
KM_mean_ARI <- mean_ARI[mean_ARI$method != "HC",]
power_generated_HC <- curve_fit(acc_table = data.frame(n = HC_mean_ARI$total_size,
                                               accuracy = HC_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "HC: Generated"))
power_generated_KM <- curve_fit(acc_table = data.frame(n = KM_mean_ARI$total_size,
                                               accuracy = KM_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "Kmeans: Generated"))
# visualization of sample size and ARI
# vis <- as.data.frame(rbind(real_ARI, generated_ARI))
# vis$datatype <- rep(c("Real","Generated"), each = nrow(real_ARI))
# ggplot(data = vis, aes(x = factor(total_size), y = ARI))+
#   geom_boxplot(aes(fill = datatype) )+
#   labs(x = "Candidate total sample size", y= "ARI for clustering")
# vis_mean <- vis %>% group_by(total_size, datatype) %>% summarise(mean_ARI = mean(ARI))
# ggplot(data = vis_mean, aes(x=total_size, y=mean_ARI))+
#    geom_point(aes(color = datatype))+
#    geom_line(aes(color = datatype))

pdf(file = "../Case/BRCAPRAD/Case_BRCAPRAD_ARI.pdf", width = 8, height = 8)
print(ggarrange(power_real_HC$graph+ylim(0.5,1), power_generated_HC$graph+ylim(0.5,1),
                power_real_KM$graph+ylim(0.5,1), power_generated_KM$graph+ylim(0.5,1),
                nrow = 2, ncol = 2, common.legend = T, legend = "bottom"))
dev.off()
```


```{r, paper F9ABC}
h_types
umap_types
p_real_types <- power_real$graph+
  theme(
        legend.text = element_text(size =10),
        axis.text.x = element_text(size =10),
        axis.text.y = element_text(size =10))
p_generated_types <- power_generated$graph+
  theme(
        legend.text = element_text(size =10),
        axis.text.x = element_text(size =10),
        axis.text.y = element_text(size =10))
ggarrange(p_real_types, p_generated_types, nrow = 1, common.legend = T, legend = "bottom")
```


# RNABRCAPRADPositive_5-2 clustering
```{r, RNABRCAPRAD, CVAE1-100, generated 500 each, quality evaluation}
# read in data
generated <- read.csv("../Case/RNABRCAPRAD/RNABRCAPRADPositive_5-2_CVAE1-100_generated.csv", header = F)
real <- read.csv("../Case/RNABRCAPRAD/RNABRCAPRADPositive_5-2.csv", header = T)
groups_real <- real$groups
groups_generated <- ifelse(generated[, ncol(generated)] == 0, "BRCA", "PRAD")
real <- select_if(real, is.numeric)
real <- log2(real + 1)
generated <- generated[,1:ncol(real)]
colnames(generated) <- colnames(real)
# heatmap quality evaluation
h_rnabrcaprad <- heatmap_eval(real[c(1:200, 1551:1750),],
             generated[c(1:200, 800:1000),], main = "")
# UMAP quality evaluation
p_umap_rna <- UMAP_eval(dat_combine = rbind(real[c(1:200, 1550:1750),],
                                        generated[c(1:200, 800:1000),]),
                    groups = c(groups_real[c(1:200, 1550:1750)],
                               groups_generated[c(1:200, 800:1000)]),
                    log = TRUE, failure = "remove")
umap_rnabrcapard <- p_umap_rna$p_umap + theme(legend.position = "right") +scale_color_aaas()
```

```{r, RNABRCAPRAD, CVAE1-100, multiple clustering}
# real clustering results
real_ARI <- eval_cluster(whole_generated = real,
                    whole_groups = groups_real,
                    n_candidate = seq(10, 300, 10),
                    n_draw = 50)
# write.table(real_ARI, "../Case/RNABRCAPRAD/ARI_real.csv",
# sep =",", row.names = F, col.names = T)
# real_ARI <- read.csv("../Case/RNABRCAPRAD/ARI_real.csv",header=T)

mean_ARI <- real_ARI %>% group_by(method, total_size) %>% summarise(mean_ARI = mean(ARI))
HC_mean_ARI <- mean_ARI[mean_ARI$method == "HC",]
KM_mean_ARI <- mean_ARI[mean_ARI$method != "HC",]
power_real_HC <- curve_fit(acc_table = data.frame(n = HC_mean_ARI$total_size,
                                               accuracy = HC_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "Real HC"))
power_real_KM <- curve_fit(acc_table = data.frame(n = KM_mean_ARI$total_size,
                                               accuracy = KM_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "Real Kmeans"))

# generated clustering results
generated_ARI <- eval_cluster(whole_generated = generated,
                         whole_groups = groups_generated,
                         n_candidate = seq(10, 300, 10),
                         n_draw = 50)
# write.table(generated_ARI, "../Case/RNABRCAPRAD/ARI_generated.csv",
# sep =",", row.names = F, col.names = T)
# generated_ARI <- read.csv("../Case/RNABRCAPRAD/ARI_generated.csv",header=T)
mean_ARI <- generated_ARI %>% group_by(method, total_size) %>% summarise(mean_ARI = mean(ARI))
HC_mean_ARI <- mean_ARI[mean_ARI$method == "HC",]
KM_mean_ARI <- mean_ARI[mean_ARI$method != "HC",]
power_generated_HC <- curve_fit(acc_table = data.frame(n = HC_mean_ARI$total_size,
                                               accuracy = HC_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "Generated HC"))
power_generated_KM <- curve_fit(acc_table = data.frame(n = KM_mean_ARI$total_size,
                                               accuracy = KM_mean_ARI$mean_ARI),
                        n_target = c(400, 500, 600), plot = TRUE,
                        annotation = c("ARI", "Generated Kmeans"))
# visualization of sample size and ARI
# vis <- as.data.frame(rbind(real_ARI, generated_ARI))
# vis$datatype <- rep(c("Real","Generated"), each = nrow(real_ARI))
# ggplot(data = vis, aes(x = factor(total_size), y = ARI))+
#   geom_boxplot(aes(fill = datatype) )+
#   labs(x = "Candidate total sample size", y= "ARI for clustering")
# vis_mean <- vis %>% group_by(total_size, datatype) %>% summarise(mean_ARI = mean(ARI))
# ggplot(data = vis_mean, aes(x=total_size, y=mean_ARI))+
#    geom_point(aes(color = datatype))+
#    geom_line(aes(color = datatype))

pdf(file = "../Case/BRCAPRAD/ari_curve_fit.pdf", width = 8, height = 8)
print(ggarrange(power_real_HC$graph, power_generated_HC$graph,
                power_real_KM$graph, power_generated_KM$graph,
                nrow = 2, ncol = 2, common.legend = T, legend = "bottom"))
dev.off()
```

# BRCASubtype.csv classification
```{r, BRCASubtype, CVAE1-20,  generated 500 each, quality evaluation}
# read in data
generated <- read.csv("../Case/BRCASubtype/BRCASubtypeSel_epochES_CVAE1-20_generated.csv", header = F)
real <- read.csv("../Case/BRCASubtype/BRCASubtypeSel.csv", header = T)
groups_real <- ifelse(real$groups == "Infiltrating Ductal Carcinoma", "Ductal", "Lobular")
groups_generated <- ifelse(generated[, ncol(generated)] == 0, "Ductal", "Lobular")
real <- select_if(real, is.numeric)
real <- log2(real + 1)
generated <- generated[,1:ncol(real)]
colnames(generated) <- colnames(real)
# heatmap quality evaluation
h_subtypes <- heatmap_eval(real[c(1:200, 881:1081),],
             generated[c(1:200, 800:1000),], main = "")
# UMAP quality evaluation
p_umap_subtypes <- UMAP_eval(dat_combine = rbind(real[c(1:200, 881:1081),],
                                        generated[c(1:200, 800:1000),]),
                    groups = c(groups_real[c(1:200, 881:1081)],
                               groups_generated[c(1:200, 800:1000)]),
                    log = TRUE, failure = "remove")
umap_subtypes <- p_umap_subtypes$p_umap + theme(legend.position = "bottom") +scale_color_aaas()
ggsave("../Case/BRCASubtype//Case_BRCASubtype_UMAP.pdf", umap_subtypes, height = 5, width = 4, unit = "in")
```

```{r, feature selection based on random forest importance}
# set.seed(11)
# folds <- createFolds(groups_real, k = 5, list = TRUE, returnTrain = FALSE)        # Get the indices of samples in the current test fold
# test_indices <- folds$Fold1
# test_data <- real[test_indices,]
# test_labels <- ifelse(groups_real[test_indices] == "Ductal", 0, 1)
# train_indices <- setdiff(1:nrow(real), test_indices)
# train_data <- real[train_indices,]
# rf <- randomForest(x = train_data, y = as.factor(train_labels),
#                         xtest = test_data, ytest = as.factor(test_labels),
#                         ntree = 100, keep.forest = TRUE) 
# importance <- as.data.frame(rf$importance)
# importance$genes <- rownames(importance)
# real_sel <- 2^(real[, importance$genes[importance$MeanDecreaseGini>1]])-1
# real_sel$groups <- groups_real
# write.table(real_sel, "../Case/BRCASubtype/BRCASubtype_Sel.csv", sep =",", row.names = F, col.names = T)
```


```{r, BRCASubtype classification accurary multiple classifier}
set.seed(111)
n_candidate <- c(seq(20, 150, 10), seq(160, 400, 25))
n_target <- seq(410, 430, 10)
save_root <- "../Case/BRCASubtype/"
metric_generated <- eval_classifier(generated, groups_generated,
                                    n_candidate, n_draw = 20, log = TRUE)
metric_real <- eval_classifier(real, groups_real, 
                               n_candidate, n_draw = 20, log = TRUE)
write.table(metric_generated, paste(save_root, "metric_generated_sel47.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
write.table(metric_real, paste(save_root, "metric_real_sel47.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
metric_generated <- read.csv("../Case/BRCASubtype/metric_generated_sel47.csv", header = TRUE)
metric_real <- read.csv("../Case/BRCASubtype/metric_real_sel47.csv", header = TRUE)
vis_classifier(metric_generated = metric_generated, 
               metric_real = metric_real,
               n_target = n_target,
               save_root = save_root)
```





```{r, BRCA subtype classification accuracy RF python}
acc_generated <- read.csv("../Case/BRCASubtype/CVAE1-10_accuracy_table.csv", 
                          header = T, sep = "\t")
mean_acc_generated <- acc_generated %>% group_by(total_size, method) %>% summarise(accuracy = mean(accuracy))
mean_acc_generated$n <- mean_acc_generated$total_size
ss_est_generated <- curve_fit(acc_table = mean_acc_generated,
                              n_target = seq(250, 300, 10))

acc_real <- read.csv("../Case/BRCASubtype/Real_accuracy_table.csv", header=T, sep="\t")
mean_acc_real <- acc_real %>% group_by(total_size, method) %>% summarise(accuracy = mean(accuracy))
mean_acc_real$n <- mean_acc_real$total_size
ss_est_real <- curve_fit(acc_table = mean_acc_real, n_target = seq(250, 300, 10))
ggarrange(ss_est_real$graph, ss_est_generated$graph, nrow = 1, common.legend = T, legend = "right")

vis <- as.data.frame(rbind(acc_real, acc_generated))
vis$datatype <- rep(c("Real","Generated"), each = nrow(acc_real))
ggplot(data = vis, aes(x = factor(total_size), y = accuracy))+
  geom_boxplot(aes(fill = datatype) )+
  labs(x = "Candidate total sample size", y= "Accuracy for classification")
vis_mean <- vis %>% group_by(total_size, datatype) %>% summarise(mean_acc = mean(accuracy))
ggplot(data = vis_mean, aes(x=total_size, y=mean_acc))+
   geom_point(aes(color = datatype))+
   geom_line(aes(color = datatype))
```


```{r, paper F10ABC}
h_subtypes
umap_subtypes
p_real_subtypes <- ss_est_real$graph+
  theme(
        legend.text = element_text(size =10),
        axis.text.x = element_text(size =10),
        axis.text.y = element_text(size =10))
p_generated_subtypes <- ss_est_generated$graph+
  theme(
        legend.text = element_text(size =10),
        axis.text.x = element_text(size =10),
        axis.text.y = element_text(size =10))
ggarrange(p_real_subtypes, p_generated_subtypes, nrow = 1, common.legend = T, legend = "bottom")
```

# RNABRCASubtype.csv classification
```{r, RNABRCASubtype data creation}
real <- read.csv("../Case/RNABRCASubtype/RNABRCAPositive_5-2.csv", header = T)
load("../Case/RNABRCASubtype/BRCAClinical.RData")
real$samples <- sapply(real$samples, function(x){paste(strsplit(x,"\\.")[[1]][1:3],collapse = "-")})
subtypes <- data.frame(samples = xml.patient$bcr_patient_barcode, groups = xml.patient$histological_type)
subtypes <- subtypes[!duplicated(subtypes), ]
real_wg <- left_join(real, subtypes, by = "samples")
real_wg <- real_wg[real_wg$groups %in% c("Infiltrating Ductal Carcinoma", "Infiltrating Lobular Carcinoma"),]
write.table(real_wg, "../Case/RNABRCASubtype/RNABRCAPositive_5-2_Subtype.csv", sep =",", 
            row.names = F, col.names = T)
```

```{r, feature selection based on random forest importance}
real <- read.csv("../Case/RNABRCASubtype/RNABRCAPositive_5-2_Subtype.csv")
groups_real <- real$groups
groups_real <- ifelse(groups_real == "Infiltrating Ductal Carcinoma", "Ductal", "Lobular")
real <- select_if(real, is.numeric)
real <- log2(real+1)
set.seed(11)
folds <- createFolds(groups_real, k = 5, list = TRUE, returnTrain = FALSE)        # Get the indices of samples in the current test fold
test_indices <- folds$Fold1
test_data <- real[test_indices,]
test_labels <- ifelse(groups_real[test_indices] == "Ductal", 0, 1)
train_indices <- setdiff(1:nrow(real), test_indices)
train_data <- real[train_indices,]
train_labels <- ifelse(groups_real[train_indices] == "Ductal", 0, 1)
rf <- randomForest(x = train_data, y = as.factor(train_labels),
                        xtest = test_data, ytest = as.factor(test_labels),
                        ntree = 100, keep.forest = TRUE)
importance <- as.data.frame(rf$importance)
importance$genes <- rownames(importance)
real_sel <- 2^(real[, importance$genes[importance$MeanDecreaseGini>0.3]])-1
real_sel$groups <- groups_real
write.table(real_sel, "../Case/RNABRCASubtype/RNABRCASubtypeSel258.csv", sep =",", row.names = F, col.names = T)
write.table(importance, "../Case/RNABRCASubtype/RNABRCASubtypeImportance.csv", sep =",", row.names = F, col.names = T)
```

```{r, RNABRCASubtype, CVAE1-150,  generated 500 each, quality evaluation}
# read in data
generated <- read.csv("../Case/RNABRCASubtype/RNABRCASubtypeSel258_epochES_CVAE1-150_generated.csv", header = F)
real <- read.csv("../Case/RNABRCASubtype/RNABRCASubtypeSel258.csv", header = T)
real <- real[order(real$groups),]
groups_real <- real$groups
groups_generated <- ifelse(generated[, ncol(generated)] == 0, "Ductal", "Lobular")
real <- select_if(real, is.numeric)
real <- log2(real + 1)
generated <- generated[,1:ncol(real)]
colnames(generated) <- colnames(real)
# heatmap quality evaluation
h_subtypes <- heatmap_eval(real[c(1:200, 905:1105),],
             generated[c(1:200, 800:1000),], main = "")
# UMAP quality evaluation
p_umap_subtypes <- UMAP_eval(dat_combine = rbind(real[c(1:200, 905:1105),],
                                        generated[c(1:200, 800:1000),]),
                    groups = c(groups_real[c(1:200, 905:1105)],
                               groups_generated[c(1:200, 800:1000)]),
                    log = TRUE, failure = "remove")
umap_subtypes <- p_umap_subtypes$p_umap + theme(legend.position = "bottom") +scale_color_aaas()
ggsave("../Case/RNABRCASubtype//Case_RNABRCASubtype_UMAP.pdf", umap_subtypes, height = 5, width = 4, unit = "in")
```




```{r, RNABRCASubtype classification accurary multiple classifier}
set.seed(333)
n_candidate <- c(seq(20, 150, 10), seq(160, 400, 25))
n_target <- seq(410, 430, 10)
save_root <- "../Case/RNABRCASubtype/"
metric_generated <- eval_classifier(generated, groups_generated,
                                    n_candidate, n_draw = 20, log = TRUE)
metric_real <- eval_classifier(real, groups_real, 
                               n_candidate, n_draw = 20, log = TRUE)
write.table(metric_generated, paste(save_root, "metric_generated_sel258_150.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
write.table(metric_real, paste(save_root, "metric_real_sel258_150.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
metric_generated <- read.csv("../Case/RNABRCASubtype/metric_generated_sel258_150.csv", header = TRUE)
metric_real <- read.csv("../Case/RNABRCASubtype/metric_real_sel258_150.csv", header = TRUE)
vis_classifier(metric_generated = metric_generated, 
               metric_real = metric_real,
               n_target = n_target,
               save_root = save_root)
```







# BRCAERPR.csv
```{r, combine miRNA profile with ERPR status}
load("/Users/yunhuiqi/Library/Mobile Documents/com~apple~CloudDocs/PhD/Interns/2021 Summer/Generative Models/DGMmicroRNA/RealData/BRCA_subtype.RData")
mr <- read.csv("/Users/yunhuiqi/Library/Mobile Documents/com~apple~CloudDocs/PhD/Interns/2021 Summer/Generative Models/DGMmicroRNA/RealData/BRCAPRAD.csv")
mr <- mr[mr$groups == "BRCA", ]
mr_bar <- sapply(mr$samples, function(x){paste(strsplit(x,"\\.")[[1]][1:3], collapse="-") })
mr$bar <- mr_bar
common_bar <- intersect(mr_bar, xml.patient$bcr_patient_barcode)
common_meta <- xml.patient[xml.patient$bcr_patient_barcode %in% common,]

common_meta <- common_meta[common_meta$histological_type == "Infiltrating Ductal Carcinoma",]
table(common_meta$breast_carcinoma_estrogen_receptor_status, common_meta$breast_carcinoma_progesterone_receptor_status)
common_meta$ERPR <- ifelse(common_meta$breast_carcinoma_estrogen_receptor_status == "Positive" & common_meta$breast_carcinoma_progesterone_receptor_status == "Positive", "ERPRpositive","Others")

filtered <- data.frame(bar = common_meta$bcr_patient_barcode, ERPR = common_meta$ERPR)
mr <- left_join(mr, filtered, by = "bar")
mr <-  mr[!is.na(mr$ERPR),]
mr$groups <- mr$ERPR
mr <- mr[,1:1883]
write.csv(mr, file="/Users/yunhuiqi/Library/Mobile Documents/com~apple~CloudDocs/PhD/Interns/2021 Summer/Generative Models/DGMmicroRNA/RealData/BRCAERPR.csv", row.names = F)

```

```{r, BRCAERPR.csv, CVAE1-10,  generated 500 each, quality evaluation}
# read in data
generated <- read.csv("../Case/BRCAERPR/BRCAERPR_CVAE1-10_generated.csv", header = F)
real <- read.csv("../Case/BRCAERPR/BRCAERPR.csv", header = T)
groups_real <- real$groups
groups_generated <- ifelse(generated[, ncol(generated)] == 0, "ERPRpositive", "Others")
real <- select_if(real, is.numeric)
real <- log2(real + 1)
generated <- generated[,1:ncol(real)]
colnames(generated) <- colnames(real)
# heatmap quality evaluation
h_ERPR <- heatmap_eval(real[c(1:200, 725:924),],
             generated[c(1:200, 801:1000),], main = "")
# UMAP quality evaluation
p_umap <- UMAP_eval(dat_combine = rbind(real[c(1:200, 725:924),],
                                        generated[c(1:200, 801:1000),]),
                    groups = c(groups_real[c(1:200, 725:924)],
                               groups_generated[c(1:200, 801:1000)]),
                    log = TRUE, failure = "remove")
umap_ERPR <- p_umap$p_umap + theme(legend.position = "right") + theme_bw()
```

```{r, BRCASubtype classification accurary multiple classifier}
set.seed(111)
n_candidate <- seq(100, 300, 20)
n_target <- seq(450, 500, 10)
save_root <- "../Case/BRCAERPR/"
metric_generated <- eval_classifier(generated, groups_generated,
                                    n_candidate, n_draw = 5, log = TRUE)
metric_real <- eval_classifier(real, groups_real, 
                               n_candidate, n_draw = 5, log = TRUE)
write.table(metric_generated, paste(save_root, "metric_generated.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
metric_generated <- read.csv("../Case/BRCAERPR/metric_generated.csv", header = TRUE)
metric_real <- read.csv("../Case/BRCAERPR/metric_real.csv", header = TRUE)
vis_classifier(metric_generated = metric_generated, 
               metric_real = metric_real,
               n_target = n_target,
               save_root = save_root)
```




```{r, python classification accuracy}
acc_generated <- read.csv("../Case/BRCAERPR/CVAE1-10_accuracy_table_small.csv", header=T, sep="\t")
mean_acc_generated <- acc_generated %>% group_by(total_size) %>% summarise(accuracy = mean(accuracy))
mean_acc_generated$n <- mean_acc_generated$total_size
ss_est_generated <- curve_fit(acc_table = mean_acc_generated, n_target = seq(150, 200, 50))

acc_real <- read.csv("../Case/BRCAERPR/Real_accuracy_table_small.csv", header=T, sep="\t")
mean_acc_real <- acc_real %>% group_by(total_size) %>% summarise(accuracy = mean(accuracy))
mean_acc_real$n <- mean_acc_real$total_size
ss_est_real <- curve_fit(acc_table = mean_acc_real, n_target =seq(150, 200, 50))
ggarrange(ss_est_real$graph, ss_est_generated$graph, nrow = 1, common.legend = T, legend = "right")

vis <- as.data.frame(rbind(acc_real, acc_generated))
vis$datatype <- rep(c("Real","Generated"), each = nrow(acc_real))
ggplot(data = vis, aes(x = factor(total_size), y = accuracy))+
  geom_boxplot(aes(fill = datatype) )+
  labs(x = "Candidate total sample size", y= "Accuracy for classification")
vis_mean <- vis %>% group_by(total_size, datatype) %>% summarise(mean_acc = mean(accuracy))
ggplot(data = vis_mean, aes(x=total_size, y=mean_acc))+
   geom_point(aes(color = datatype))+
   geom_line(aes(color = datatype))
```





# MSK paired data 

```{r, special evaluation functions}
random_draw <- function(generated, real, groups_generated, groups_real, n_draw = 10){
  # This function randomly draw the same size of generated samples as the real samples
  # Ruturn a list of combined datasets with first half real, and second half generated, including all features + groups + datasets(real, generated)
  subtypes <- unique(groups_real)
  n_subtypes <- table(groups_real)
  n_generated_subtypes <- table(groups_generated)
  draw_list <- list()
  for (draw in 1:n_draw) {
    draw_generated <- matrix(0, nrow = 1, ncol = ncol(real))
    draw_real <- matrix(0, nrow = 1, ncol = ncol(real))
    colnames(draw_generated) <- colnames(real)
    colnames(draw_real) <- colnames(real)
    for (i_subtype in 1:length(subtypes)) {
      subtype <- subtypes[i_subtype]
      n_subtype <- n_subtypes[i_subtype]
      n_generated_subtype <- n_generated_subtypes[i_subtype]
      draw_generated <- rbind(draw_generated, generated[groups_generated == subtype,][sample(1:n_generated_subtype, n_subtype),])
      draw_real <- rbind(draw_real, real[groups_real == subtype,])
    }
    draw_generated <- as.data.frame(draw_generated[2:nrow(draw_generated),])
    draw_real <- as.data.frame(draw_real[2:nrow(draw_real),])
    draw_df <- as.data.frame(rbind(draw_real, draw_generated))
    draw_df$Datasets <- rep(c("Real","Generated"), each = nrow(real))
    draw_df$Groups <- rep(rep(subtypes, n_subtypes), 2)
    draw_list <- append(draw_list, list(draw_df))
  }
  names(draw_list) <- paste("draw_df", 1:n_draw, sep = "_")
  return(draw_list)
}
DEA_eval=function(dat_combine, groups = NULL, log = TRUE, replace = FALSE){
  # This function compares real data and generated data from the perspective of differential expression analysis
  # @params: dat_combine - data mtrix with the upper half real, lower half generated
  # @params: groups - vector containing the group information of samples
  # @params: log - whether the data is log2 transformed
  # @params: replace - whether to replace the zero features in generated data with the real ones
  dat_real = dat_combine[1:(nrow(dat_combine)/2), ]
  dat_fake = dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  if(replace){
    dat_fake[ ,apply(dat_fake,2,sd)==0] = dat_real[ ,apply(dat_fake,2,sd)==0]
    dat_combine = rbind(dat_real, dat_fake)
  }
  if(is.null(groups)){
     groups_real = rep(c(rep("MXF",9), rep("PMFH",9)),3)
     groups_fake = groups_real
     groups_combine = rep(c(rep("MXF",9), rep("PMFH",9)),6)
  }
  else{
    if(length(groups) != nrow(dat_combine)){
      groups_combine = c(groups,groups)
      groups_real = groups
      groups_fake = groups
    }
    else{
      groups_combine = groups
      groups_real = groups_combine[1:(length(groups_combine)/2)]
      groups_fake = groups_combine[(length(groups_combine)/2+1):length(groups_combine)]
      }
  }
  if(log){
    combine_DEA = precision.seq::DE.voom(2^t(dat_combine)-1, groups_combine)
    real_DEA = precision.seq::DE.voom(2^t(dat_real)-1, groups_real)
    fake_FA = (2^t(dat_fake)-1)
    fake_FA[fake_FA<0] = 0
    generated_DEA = precision.seq::DE.voom(round(fake_FA), groups_fake)
  }
  
  for (i.pval in 1:length(combine_DEA$p.val)) {
    if(combine_DEA$p.val[i.pval] == 0){combine_DEA$p.val[i.pval] = real_DEA$p.val[i.pval]}
  }
  
  #### generated vs real
  # mean vs sd
  plot(apply(dat_real, 2, mean), apply(dat_real,2,sd),
       main = "mean vs sd", xlab = "Feature mean", ylab = "Feature std")
  points(apply(dat_fake, 2, mean), apply(dat_fake, 2, sd), col = "red")
  legend("topright",pch = c(1,1), col = c("black","red"), legend = c("Real", "Generated"))
  
  # layout(matrix(c(1, 2, 3, 4), nrow = 2, byrow = T))
  
  # -log10 pvalue cc
  plot(-log10((real_DEA$p.val)), -log10((generated_DEA$p.val)),
       xlim = c(0,6), ylim = c(0,6), xlab = "Real",ylab = "Generated",
       main = paste("-log10 pvalues, ccc=", 
                    round(epiR::epi.ccc((-log10(real_DEA$p.val)), (-log10(generated_DEA$p.val)))$rho.c[1], 4), 
                    sep = ""))
  abline(a = 0, b = 1)
  
  # pvalue cc
  plot((generated_DEA$p.val), ylim = c(0,1), col = "red", xlab = "Genes", ylab = "pvalues",
       main = paste("pvalues, ccc=", 
                    round(epiR::epi.ccc(((real_DEA$p.val)), ((generated_DEA$p.val)))$rho.c[1], 4), 
                    sep = ""))
  points((real_DEA$p.val), col = "black")
  legend("topleft", legend = c("Real","Generated"), pch = c(1,1), col = c("black", "red"))
  
  # log2FC of all genes
  plot(real_DEA$log2.FC, main = "log2.FC", xlab = "Genes", ylab = "log2FC", ylim = c(-3,3))
  points(generated_DEA$log2.FC, col = "red")
  legend("topright", legend = c("Real","Generated"), pch = c(1,1), col = c("black","red"))
  
  if(is.null(real_DEA$id.list)){real_DEA$id.list = colnames(dat_combine)}
  
  # log2FC of real significant genes
  plot(real_DEA$log2.FC[real_DEA$id.list], generated_DEA$log2.FC[real_DEA$id.list],
       xlab = "Real",ylab = "Generated", main = "log2FC of real DEA genes",
       ylim = c(-3,3), xlim = c(-3,3))
  abline(a = 0, b = 1)
  
  # significance results
  print(paste("DE in real =", length(real_DEA$id.list),
              "DE in generated =", length(generated_DEA$id.list),
              "DE in common = ",   length(intersect(real_DEA$id.list, generated_DEA$id.list)),sep = " "))
  # layout(1)
}
cluster_single_eval=function(dat_combine, no_clusters = 8, groups = NULL, replace = F){
  # This function perform the clustering on real and generated bench OR test dataset
  # @params: dat_combine - rbind(real, generated)
  # @params: no_clusters - number of clusters 
  # @params: groups - information about groups of all the samples
  # @params: replace - whether or not to replace the zero features in the generated data using real ones
  
  if(replace){
    zero_index = apply(dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ], 2, sd) == 0
    dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), zero_index] = dat_combine[1:(nrow(dat_combine)/2), zero_index]
  }
  if(is.null(groups)){
     groups_combine = rep(c(rep("MXF", 9), rep("PMFH", 9)), 6)
  }
  else{
    if(length(groups) != nrow(dat_combine)){
      groups_combine = c(groups, groups)
    }
    else{
      groups_combine = groups
    }
  }
  datatype = rep(c("Real", "Generated"), rep(nrow(dat_combine)/2, 2))
  d = dist(dat_combine, method = "euclidean") 
  fit = hclust(d, method = "ward")
  plot(fit)
  clusters = cutree(fit, k = no_clusters)
  rect.hclust(fit, k = no_clusters, border = "red")
  df = data.frame(groups = groups_combine, dataset = datatype, 
                  cluster = as.factor(clusters), sample = rep(1:(nrow(dat_combine)/2), 2)) 
  ggplot(data = df)+
    geom_point(aes(x = sample, y = groups, color = cluster))+
    facet_wrap(vars(dataset))+
    labs(x="Sample index", y="Subtypes")
}
correlation_eval=function(dat_combine, groups){
  # This function comput the pairwise correlations between real dna generated within subtypes
  # @params: dat_combine - data mtrix rbind(real, generated)
  # @params: groups - vector containing the group information of samples
  dat_real = dat_combine[1:(nrow(dat_combine)/2), ]
  dat_fake = dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  sample_names = paste(groups[1:(length(groups)/2)], 1:nrow(dat_real))
  rownames(dat_real) = sample_names
  rownames(dat_fake) = sample_names
  cormat_real = melt(cor(t(dat_real)))
  cormat_fake = melt(cor(t(dat_fake)))
  colnames(cormat_real) = c("sample1", "sample2", "correlation")
  colnames(cormat_fake) = c("sample1", "sample2", "correlation")
  cormat_real$withinSubtype = ifelse(substr(cormat_real$sample1, 1, 3) == substr(cormat_real$sample2, 1, 3), "Yes", "No")
  cormat_fake$withinSubtype = ifelse(substr(cormat_fake$sample1, 1, 3) == substr(cormat_fake$sample2, 1, 3), "Yes", "No")
  p_real = ggplot(cormat_real[cormat_real$correlation<1, ], 
                  aes(x = sample2, y = correlation, fill = withinSubtype)) +
    geom_boxplot(show.legend = F)+
    ylim(-1, 1)+
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank())+
    labs(title = "Real")
  p_fake = ggplot(cormat_fake[cormat_fake$correlation<1, ],
                  aes(x = sample2, y = correlation, fill = withinSubtype))+
    geom_boxplot()+
    theme(axis.text.x = element_text(angle = 90, size = 4))+
    ylim(-1, 1)+
    labs(title = "Generated", x = "Samples")+
    theme(legend.position = "bottom")
  
  cowplot::plot_grid(p_real, p_fake, nrow = 2, rel_heights = c(4.8/11, 6.2/11))
}
cluster_pair_eval=function(dat_combine, no_clusters = 8, groups = NULL, replace = F){
  # This function perform the clustering on real and generated bench OR test dataset
  # @params: dat_combine - rbind(real, generated), cbind(bench, test)
  # @params: no_clusters - number of clusters 
  # @params: groups - infromation about groups of all the samples
  # @params: replace - whether or not to replace the zero features in the generated data using real ones

  if(replace){
    zero_index = apply(dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ], 2, sd) == 0
    dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), zero_index] = dat_combine[1:(nrow(dat_combine)/2), zero_index]
  }
  colnames(dat_combine) = rep(paste("feature", 1:(ncol(dat_combine)/2), sep = ""), 2)
  dat = rbind(dat_combine[ , 1:(ncol(dat_combine)/2)],
              dat_combine[ , (ncol(dat_combine)/2+1):ncol(dat_combine)])
  if(is.null(groups)){
    groups_combine = rep(c(rep("MXF", 9), rep("PMFH", 9)), 6)
  }
  else{
    if(length(groups) != nrow(dat_combine)){
      groups_combine = c(groups, groups)
    }
    else{groups_combine = groups}
  }
  datatype = rep(rep(c("Real", "Generated"), rep(nrow(dat_combine)/2, 2)), 2)
  pair = rep(c("Bench", "Test"), c(nrow(dat)/2, nrow(dat)/2))
  d = dist(dat, method = "euclidean") 
  fit = hclust(d, method = "ward")
  plot(fit) 
  clusters = cutree(fit, k = no_clusters) 
  rect.hclust(fit, k = no_clusters, border = "red")
  df = data.frame(groups = groups_combine, dataset = datatype,
                  cluster = as.factor(clusters), sample = rep(1:(nrow(dat_combine)/2), 4), pair = pair)
  ggplot(data = df)+
    geom_point(aes(x = sample,y = groups,color = cluster)) +
    facet_grid(rows = vars(dataset), cols = vars(pair)) +
    theme_bw() +
    labs(x = "Sample index", y = "Subtypes")
}
```

```{r, read in data and random draw}
# read in data
generated <- read.csv("../Case/MSKpair/MSKpair_AEhead_CVAE1-10_generated.csv", header = F)
real <- read.csv("../Case/MSKpair/MSKpair.csv", header = T)
groups_real <- real$groups
groups_generated <- ifelse(generated[, ncol(generated)] == 0, "MXF", "PMFH")
real <- select_if(real, is.numeric)
real <- log2(real + 1)
generated <- generated[,1:ncol(real)]
colnames(generated) <- colnames(real)

# draw same size generated samples and combine with real samples

combine_log_list <- random_draw(generated, real, groups_generated, groups_real, n_draw = 1)
combine_log <- combine_log_list[[1]]
```

### combined real and generated, combined test and bench 
```{r, combined real and generated, combined test and bench}
dat_combine <- combine_log[,1:2066]
# heatmap quality evaluation 
heatmap_eval(dat_combine, main = "")
# UMAP quality evaluation 
p_umap <- UMAP_eval(dat_combine = dat_combine,
                    groups = combine_log$Groups,
                    log = TRUE, failure = "remove")
p_umap$p_umap + theme(legend.position = "right") + theme_bw() + scale_color_jco()
# Clustering quality evaluation
cluster_pair_eval(dat_combine, no_clusters = 2, groups = combine_log$Groups, replace = T)
```

### combined real and generated, only test dataset
```{r, combined real and generated, only test dataset}
type <- "Test"
type_ind <- 1034:2066
dat_combine <- as.matrix(combine_log[,type_ind])
groups <- combine_log$Groups
DEA_eval(dat_combine = dat_combine, groups = groups, log = TRUE, replace = TRUE)
cluster_single_eval(dat_combine, no_clusters = 2, groups = groups, replace = T)
correlation_eval(dat_combine, groups)
```
### combined real and generated, only benchmark dataset
```{r, combined real and generated, only benchmark dataset}
type <- "Benchmark"
type_ind <- 1:1033
dat_combine <- as.matrix(combine_log[,type_ind])
groups <- combine_log$Groups
DEA_eval(dat_combine = dat_combine, groups = groups, log = TRUE, replace = TRUE)
cluster_single_eval(dat_combine, no_clusters = 2, groups = groups, replace = T)
correlation_eval(dat_combine, groups)
```


### MAF with AEhead5 evaluation 
```{r, read in data}
generated_mxf <- read.csv("/Users/yunhuiqi/Downloads/MSKpair_MXF_AEhead5_maf_5400_Draw1.csv", header = F, nrows = 500)

generated_pmfh <- read.csv("/Users/yunhuiqi/Downloads/MSKpair_MXF_AEhead5_maf_5400_Draw1.csv", header = F, nrows = 500)

generated <- rbind(generated_mxf, generated_pmfh)

groups_generated <- rep(c("MXF","PMFH"), each = 500)

real <- read.csv("../Case/MSKpair/MSKpair.csv", header = T)

groups_real <- real$groups

real <- select_if(real, is.numeric)
real <- log2(real + 1)
colnames(generated) <- colnames(real)


hand_real <- real[, 1034:2066] - real[, 1:1033]

hand_generated <- generated[, 1034:2066] - generated[, 1:1033]

dat_combine <- rbind(real, generated)


hand_combine <- rbind(hand_real, hand_generated)
combine_type <- rep(c("real","generated"),c(54, 1000))
groups_combine <- c(groups_real, groups_generated)


```
```{r,whole samples}

# bench & test, both subtypes
heatmap_eval(dat1 = real, dat2 = generated[c(1:27,474:500), ], main = "Whole")
p_umap <- UMAP_eval(dat_combine, combine_type, groups_combine, log = T, failure = "remove") 
p_umap$p_umap + theme(legend.position = "right") + theme_bw() + scale_color_jco()

# separte sets, both subtypes
bench <- dat_combine[,1:1033]
test <- dat_combine[,1034:2066]
colnames(test) <- colnames(bench)
dat_double_combine <- rbind(bench, test)
datatype <- c(paste("bench",combine_type,sep = "_"),paste("test",combine_type,sep = "_"))
mat <- as.matrix(dat_double_combine)
UMAP_fit = umap::umap(mat)
UMAP_df = UMAP_fit$layout %>% 
          as.data.frame() %>%
          dplyr::rename(UMAP1 = "V1", UMAP2 = "V2") %>%
          mutate(ID = row_number())
factor_df = data.frame(groups = groups_combine, datatype = datatype) %>% mutate(ID=row_number())
plot_df = UMAP_df %>% inner_join(factor_df, by="ID")
p_umap <- plot_df %>% ggplot(aes(x = UMAP1, y = UMAP2, 
                                color = datatype, shape = groups))+
                          geom_point()+
                          labs(color = "Datatype", shape = "Groups")+
                          theme_bw()+
                          scale_color_manual(values=c("green","blue","pink","darkorange"))+
                          theme(
                            strip.text = element_text(face = "bold", size = rel(0.8)),
                            strip.background = element_blank(),
                            panel.border = element_rect(colour = "black", fill = NA),
                            axis.text.x = element_blank(),
                            axis.text.y = element_blank(),
                            panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank(),
                            axis.line = element_blank())+
      guides(color = guide_legend(order=1, nrow=4),
             shape = guide_legend(order=2, nrow=2))+
      theme(legend.position="left", legend.title = element_text(size=10),
            legend.text = element_text(size=10) )
p_umap
```
```{r, handling effects}
heatmap_eval(dat1 = hand_real, dat2 = hand_generated[c(1:27,474:500), ], main = "Handling")

p_umap <- UMAP_eval(hand_combine, combine_type, groups_combine, log = T, failure = "remove")
p_umap$p_umap + theme(legend.position = "right") + theme_bw() + scale_color_jco()
```



# MSK survival
1. Add survival probability using Kaplan-Meier fit as column SurvProb 
```{r}
library(survival)
library(ggsurvfit)
MXF <- read.csv("../Case/MSKSurvival/MSKpair_MXF_merge.csv")
PMFH <- read.csv("../Case/MSKSurvival/MSKpair_PMFH_merge.csv")
dat <- PMFH
survfit <- survfit(Surv(ttDR, DRFS_STATUS) ~ 1, data = dat)
survest <- stepfun(survfit$time, c(1, survfit$surv))
MXF$SurvProb <- survest(dat$ttDR)
PMFH$SurvProb <- survest(dat$ttDR)
survfit2(Surv(ttDR, DRFS_STATUS) ~ 1, data = dat) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  )
```

2. Add an extra column as indicator of DRFS_STATUS as the Gaussian Mixture of two mode.

```{r}
dat <- PMFH
indicator <- dat$DRFS_STATUS
DRFS_mixprob <- rep(NA, length(indicator))
DRFS_mixprob[indicator==0] <- rnorm(sum(indicator == 0), mean = 100, sd = 20)
DRFS_mixprob[indicator==1] <- rnorm(sum(indicator == 1), mean = -100, sd = 20)
MXF$DRFS_mixprob <- DRFS_mixprob
PMFH$DRFS_mixprob <- DRFS_mixprob
```

3. write new data with survival prob as SurvProb and mixture DRFS_mixprob
```{r}
write.table(MXF,
            paste("../Case/MSKSurvival/", "MSKSurvival_MXF.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
write.table(PMFH,
            paste("../Case/MSKSurvival/", "MSKSurvival_PMFH.csv", sep = ""),
            sep =",", row.names = F, col.names = T)
```

4. evaluate MAF generated data with no offline augmentation
```{r}
real <- read.csv("../Case/MSKSurvival/MSKSurvival_MXF.csv", header = T)
generated <- read.csv("../Case/MSKSurvival/MSKSurvival_MXF_offaug_None_maf_27_Draw1.csv", header = F)
df <- data.frame(SurvProb = c(real$SurvProb, generated[, 2067]), DRFS_mixprob = c(real$DRFS_mixprob, generated[, 2068]), Type = rep(c("Real","Generated"), c(nrow(real), nrow(generated))))
ggplot(df)+
  geom_histogram(aes(x = SurvProb))+
  facet_wrap(vars(Type), scales = "free_y")
ggplot(df)+
  geom_histogram(aes (x = DRFS_mixprob))+
  facet_wrap(vars(Type), scales = "free_y")
```
4. evaluate MAF generated data with 10 iteration AE head augmentation
```{r}
real <- read.csv("../Case/MSKSurvival/MSKSurvival_MXF.csv", header = T)
generated <- read.csv("../Case/MSKSurvival/MSKSurvival_MXF_AEhead_maf_27_Draw1.csv", header = F)
generated_prob <- generated[, 2067]
real_prob <- real$SurvProb
hist(real_prob)
hist(generated_prob)
df <- data.frame(SurvProb = c(real_prob, generated_prob), DRFS_mixprob = c(real$DRFS_mixprob, generated[, 2068]), Type = rep(c("Real","Generated"), c(nrow(real), nrow(generated))))
ggplot(df)+
  geom_histogram(aes(x = SurvProb))+
  facet_wrap(vars(Type), scales = "free_y")
ggplot(df)+
  geom_histogram(aes (x = DRFS_mixprob))+
  facet_wrap(vars(Type), scales = "free_y")
```
