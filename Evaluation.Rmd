---
title: "Evaluation of Samples Generated by DGMs Using Pilot Data"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r, import packages}
library(ggplot2)
library(Rtsne)
library(tidyverse)
library(cowplot)
library(aricode)
library(RColorBrewer)
library(DANA)
library(dgof)
library(precision.seq)
library(epiR)
library(umap)
mycolors <- c(brewer.pal(n = 8, name = "Blues")[c(2,4,6)], brewer.pal(n = 8, name = "Oranges")[c(2,4,6)], brewer.pal(n = 8, name = "Greens")[c(2,4,6)])
```

```{r, set file source location as working directory}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```


```{r, functions borrow from DANA}
listClusters <- function(geneClusters) {
  geneClusters <- as.factor(geneClusters)
  clusters <- list()
  clusters <- lapply(
    levels(geneClusters),
    function(x) names(geneClusters)[geneClusters==x]
  )
  names(clusters) <- levels(geneClusters)
  return(clusters)
}
compute.cc <- function(rawCor, normCor, clusters) {
  # remove genes that are not present in both models
  rawCor <- rawCor[!is.na(match(colnames(rawCor), colnames(normCor))),
                   !is.na(match(colnames(rawCor), colnames(normCor)))]
  normCor <- normCor[!is.na(match(colnames(normCor), colnames(rawCor))),
                     !is.na(match(colnames(normCor), colnames(rawCor)))]

  # consider only cluster with multiple genes
  clusters <- clusters[lengths(clusters) > 1]
  clusters.raw <- c()
  clusters.norm <- c()
  for (clust in clusters) {
    # only consider cluster genes that are positive controls
    clust.genes <- clust[stats::na.omit(match(colnames(rawCor), clust))]
    if (length(clust.genes) < 2) {
      next  # disregard clusters with less than 2 genes
    }
    # subset of correlations in the cluster
    rawCor.clust <- rawCor[clust.genes, clust.genes]
    clusters.raw <- c(clusters.raw, rawCor.clust[upper.tri(rawCor.clust)])
    normCor.clust <- normCor[clust.genes, clust.genes]
    clusters.norm <- c(clusters.norm, normCor.clust[upper.tri(normCor.clust)])
  }

  cc <- DescTools::CCC(as.vector(clusters.raw),as.vector(clusters.norm))$rho.c$est

  return(cc)
}

```


```{r, define functions}
get_bind_list <- function(real, generated, real_log = F, generated_log = T){
  
  # This function bind the real samples with the generated samples.
  # @param: real - csv path of real dataset, N * p with header gene names and samples or groups
  # @param: generated -  path of generated dataset, logged, no header no row names
  # @param: real_log - whether real data are already logged, usually F
  # @param: generated_log - whether generated data are already logged, usually T
  # @return: bind_list -lists of 25 replications of combined datasets, each is 2N * p, first N are real samples, second N are generated samples, all samples are logged
  # @return: groups - vector of groups information, if there is no group in real data, groups = NULL, if there is groups, groups is a (1 + 25) * N vector, is the group info for (real, bind_list)
  # @return: samples - sample names of real data
  repli <- 5
  draw <- 5
  
  real <- read.csv(real, header = T)
  sample_names <- real$sample
  if("groups" %in% colnames(real)){groups <- real$groups}
  else{groups <- NULL}
  draw_paths <- paste("../GeneratedData/", generated, "_Draw", 1:draw, ".csv", sep = "")
  generated <- read.csv(draw_paths[1], header = F)
  for(draw_ind in 2:draw) {
    generated_draw <- read.csv(draw_paths[draw_ind], header = F)
    generated <- rbind(generated, generated_draw)
  }
  if("groups" %in% colnames(real)){
    g_default <- groups[1]
    g_other <- unique(groups)[unique(groups) != g_default]
    groups <- c(groups, ifelse(generated[,ncol(generated)] == 0, g_default, g_other))
    generated <- generated[, 1:(ncol(generated)-1)]
    }
  
  real <- select_if(real, is.numeric)
  feature_names <- unlist(lapply(strsplit(colnames(real),"\\."), 
                                 function(x){paste(x, collapse = "-")}))
  
  if(!real_log){real <- log2(real+1)}
  if(!generated_log){generated <- log2(generated+1)}
  stopifnot((nrow(real) * (repli * draw) == nrow(generated)) & (ncol(real) == ncol(generated)))
  
  colnames(generated) <- feature_names
  colnames(real) <- feature_names
  rownames(real) <- sample_names
  
  N <- nrow(real)
  bind_list <- list()
  for (repe in 1:(repli * draw)) {
      bind_list[[repe]] <- rbind(real, generated[((repe-1) * N + 1) : (repe * N), ])
      colnames(bind_list[[repe]]) <- feature_names
  }
  rm(generated)
  return(list(bind_list = bind_list, groups = groups, samples = sample_names))
}

heatmap_eval <-  function(dat_combine, main, log = TRUE){
  
  # This function plot the heatmap of data matrix dat_combine
  # @param: dat_combine - the log2 data matrix with samples in rows, features in columns
  # @param: main - the title for the heatmap
  # @param: log - whether your dat_combine is log2 transformed
  
  if (!log) {
    dat_combine <- log2(dat_combine+1)
  }
  
  dat <- data.frame(column = rep(1:ncol(dat_combine), rep(nrow(dat_combine), ncol(dat_combine))),
                   row = rep(1:nrow(dat_combine), ncol(dat_combine)),
                   value = (c(as.matrix(dat_combine))))
  
  p_heat <- ggplot(data = dat, aes(x = column, y = row, fill = value))+
    geom_tile()+
    theme_bw()+
    labs(title = main, x = "Genes", y = "Samples")
  
  return(p_heat)
}

DEA_eval <- function(dat_combine, groups = NULL, log = TRUE, failure= c("replace", "remove"), plot = FALSE){
  
  # This function compares real data and generated data from the perspective of differential expression analysis
  # @param: dat_combine - data matrix with the upper half real, lower half generated
  # @param: groups - vector containing the group information of samples
  # @param: log - whether the data is log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  # @param: plot - whether to plot 
  # @return: return the concordance correlation of -log10pvalue and log2FC
  
  
  genes <- colnames(dat_combine)
  
  if(log){
    dat_combine <- 2^(dat_combine) - 1
    dat_combine[dat_combine < 0] <- 0
    dat_combine <- round(dat_combine)
  }
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
  if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
    genes <- colnames(dat_combine)
  }
  else{
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  if(nrow(dat_combine) <= 2){res <- NA}
  else{
    if(is.null(groups)){
       groups_real <- rep("A", nrow(dat_real))
       groups_real[sample(1:nrow(dat_real), round(0.5*nrow(dat_real)),replace = F)] <- "B"
       groups_generated <- groups_real
       groups_combine <- c(groups_real, groups_generated)
    }
    else if(length(groups) == 0.5*nrow(dat_combine)){
        groups_combine <- c(groups, groups)
        groups_real <-  groups
        groups_generated <-  groups
      }
    else{
        groups_combine <- groups
        groups_real <- groups_combine[1:(length(groups_combine)/2)]
        groups_generated <- groups_combine[(length(groups_combine)/2+1):length(groups_combine)]
    }
    
    dat_real <- as.matrix(dat_real)
    dat_generated <- as.matrix(dat_generated)
  
    DEA_real <- precision.seq::DE.voom(t(dat_real), groups_real)
    DEA_generated <- precision.seq::DE.voom(t(dat_generated), groups_generated)
    if(is.null(DEA_real$id.list)){DEA_real$id.list = colnames(dat_combine)}
   
    DEA_real$p.val[!is.finite(log10(DEA_real$p.val))] <- min(DEA_real$p.val[is.finite(log10(DEA_real$p.val))])
    
    DEA_generated$p.val[!is.finite(log10(DEA_generated$p.val))] <- min(DEA_generated$p.val[is.finite(log10(DEA_generated$p.val))])
    
    #### generated vs real
    res <- c(ccc_log10pvalue = round(epiR::epi.ccc((-log10(DEA_real$p.val[genes])), (-log10(DEA_generated$p.val[genes])))$rho.c[1], 4),
             ccc_log2FC = round(epiR::epi.ccc(DEA_real$log2.FC[DEA_real$id.list], DEA_generated$log2.FC[DEA_real$id.list])$rho.c[1], 4))
   
    
    if(plot){
      
    layout(matrix(c(1, 2, 3), nrow = 1, byrow = T))
      
    # mean vs sd
    plot(apply(dat_real, 2, mean), apply(dat_real, 2, sd),
         main = "mean vs sd", xlab = "Feature mean", ylab = "Feature std")
    points(apply(dat_generated, 2, mean), apply(dat_generated, 2, sd), col = "red")
    legend("topright", pch = c(1,1), col = c("black","red"), legend = c("Real", "Generated"))
  
    # -log10 pvalue ccc
    plot(-log10((DEA_real$p.val[genes])), -log10((DEA_generated$p.val[genes])),
          xlab = "Real",ylab = "Generated",
         main = paste("-log10 pvalues, ccc=", res$ccc_log10pvalue, sep = ""))
    abline(a = 0, b = 1)
    
    # log2FC of DE or all genes
    plot(DEA_real$log2.FC[DEA_real$id.list], DEA_generated$log2.FC[DEA_real$id.list],
         xlab = "Real",ylab = "Generated", main = paste( "log2FC of real DE genes, ccc =",res$ccc_log2FC, sep=""))
    abline(a = 0, b = 1)
    
    layout(1)
    }
  }
  
 return(res)
}

cluster_eval <- function(dat_combine, groups = NULL, log = TRUE, failure= c("replace", "remove"), plot = FALSE){
  # This function perform the clustering on the combined datasets
  # @param: dat_combine - data matrix with the upper half real, lower half generated
  # @param: groups - vector containing the group information of samples
  # @param: log - whether the data is log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  # @param: plot - whether to plot 
  # @return: if groups are given, return ARI index, otherwise, return cARI = 1-ARI(datatype, clusters)
  
  if(!log){
    dat_combine <- log2(dat_combine + 1)
  }
  
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
 if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  else if(failure == "replace"){
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  
  if(is.null(groups)){no_clusters <- 2}
  else{
    if(length(groups) == 0.5*nrow(dat_combine)){
      groups_combine <- c(groups, groups)
      groups_real <-  groups
      groups_generated <-  groups
    }
    else{
      groups_combine <- groups
      groups_real <- groups_combine[1:(length(groups_combine)/2)]
      groups_generated <- groups_combine[(length(groups_combine)/2+1):length(groups_combine)]
    }
    no_clusters <- length(unique(groups_combine))
  }
  
  datatype <- rep(c("Real", "Generated"), rep(nrow(dat_combine)/2, 2))
  d <- dist(dat_combine, method = "euclidean") 
  fit <- hclust(d, method = "ward.D2")
  clusters <- cutree(fit, k = no_clusters)
  if(is.null(groups)){
    if(plot){
      rect.hclust(fit, k = no_clusters, border = "red")
      df <- data.frame(dataset = datatype, cluster = as.factor(clusters), sample = rep(1:(nrow(dat_combine)/2), 2)) 
      ggplot(data = df)+
        geom_point(aes(x = sample, y = dataset, color = cluster))+
        labs(x="Sample index", y="Dataset")
    }
    return(1-abs(round(aricode::ARI(datatype, clusters),4)))
  }
  else{
    if(plot){
      rect.hclust(fit, k = no_clusters, border = "red")
      df <- data.frame(groups = groups_combine, dataset = datatype, 
                      cluster = as.factor(clusters), sample = rep(1:(nrow(dat_combine)/2), 2)) 
      ggplot(data = df)+
        geom_point(aes(x = sample, y = groups, color = cluster))+
        facet_wrap(vars(dataset))+
        labs(x="Sample index", y="Groups")
    }
    return(round(aricode::ARI(groups_combine, clusters ),4))
  }
  
  
}

tSNE_eval <- function(dat_combine, groups = NULL, log = TRUE, failure= c("replace", "remove")){
  # This function perform tSNE dimension reduction to real and generated combined dataset 
  # and check whether the main variation lies between real and generated samples
  # @param: dat_combine - data matrix with samples in row, features in col, first N samples are real, second N samples are generated
  # @param: groups - groups information, samples from different groups are represented by different point shape
  # @param: log - whether the data are log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  if(!log){
    dat_combine <- log2(dat_combine+1)
  }
  
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
 if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  else if(failure == "replace"){
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  if(length(groups) == 0.5*nrow(dat_combine)){
      groups_combine <- c(groups, groups)
      groups_real <-  groups
      groups_generated <-  groups
    }
  else{
      groups_combine <- groups
      groups_real <- groups_combine[1:(length(groups_combine)/2)]
      groups_generated <- groups_combine[(length(groups_combine)/2+1):length(groups_combine)]
  }
  mat <- as.matrix(dat_combine)
  datatype <- rep(c("real","generated"), rep(nrow(mat)/2, 2))
  tSNE_fit <- Rtsne::Rtsne(mat)
  tSNE_df <- tSNE_fit$Y %>% 
             as.data.frame() %>%
             rename(tSNE1 = "V1", tSNE2 = "V2") %>%
             mutate(ID = row_number())
  if(is.null(groups)){
    factor_df <- data.frame(datatype = datatype) %>% mutate(ID=row_number())
    plot_df <- tSNE_df %>% inner_join(factor_df, by="ID")
    plot_df %>% ggplot(aes(x = tSNE1, y = tSNE2, color = datatype))+
                 geom_point()+
                 theme(legend.position="bottom")+
                 labs(title="tSNE plot of combined samples")
  }
  else{
    factor_df <- data.frame(groups = groups_combine, datatype = datatype) %>% mutate(ID=row_number())
    plot_df <- tSNE_df %>% inner_join(factor_df, by="ID")
    plot_df %>% ggplot(aes(x = tSNE1, y = tSNE2, color = datatype, shape = groups))+
                 geom_point()+
                 theme(legend.position="bottom")+
                 labs(title="tSNE plot of combined samples")+
                 themebw()
  }
}

UMAP_eval <- function(dat_combine, groups = NULL, log = TRUE, failure= c("replace", "remove")){
  # This function perform UMAP dimension reduction to real and generated combined dataset 
  # and check whether the main variation lies between real and generated samples
  # @param: dat_combine - data matrix with samples in row, features in col, first N samples are real, second N samples are generated
  # @param: groups - groups information, samples from different groups are represented by different point shape
  # @param: log - whether the data are log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  if(!log){
    dat_combine <- log2(dat_combine+1)
  }
  
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
 if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  else if(failure == "replace"){
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  if(length(groups) == 0.5*nrow(dat_combine)){
      groups_combine <- c(groups, groups)
      groups_real <-  groups
      groups_generated <-  groups
    }
  else{
      groups_combine <- groups
      groups_real <- groups_combine[1:(length(groups_combine)/2)]
      groups_generated <- groups_combine[(length(groups_combine)/2+1):length(groups_combine)]
  }
  mat <- as.matrix(dat_combine)
  datatype <- rep(c("real","generated"), rep(nrow(mat)/2, 2))
  UMAP_fit <- umap::umap(mat)
  UMAP_df <- UMAP_fit$layout %>% 
             as.data.frame() %>%
             rename(UMAP1 = "V1", UMAP2 = "V2") %>%
             mutate(ID = row_number())
  if(is.null(groups)){
    factor_df <- data.frame(datatype = datatype) %>% mutate(ID=row_number())
    plot_df <- UMAP_df %>% inner_join(factor_df, by="ID")
    p_umap <- plot_df %>% ggplot(aes(x = UMAP1, y = UMAP2, 
                                    color = datatype))+
                          geom_point()+
                          theme(legend.position="bottom")+
                          labs(title="UMAP plot of combined samples")
  }
  else{
    factor_df <- data.frame(groups = groups_combine, datatype = datatype) %>% mutate(ID=row_number())
    plot_df <- UMAP_df %>% inner_join(factor_df, by="ID")
    p_umap <- plot_df %>% ggplot(aes(x = UMAP1, y = UMAP2, 
                                     color = datatype, shape = groups))+
                          geom_point()+
                          theme(legend.position="bottom")+
                          labs(title="UMAP plot of combined samples")+
                          theme_bw()
  }
  return(list(plot_df = plot_df, p_umap = p_umap))
}

ccpos_eval <- function(dat_combine, log = TRUE, failure = c("replace", "remove"), coords, poly = F, thres = NULL){
  # This function perform DANA comparison of concordance correlation which measures the preservation of biological signals real versus generated
  # @param: dat_combine - data matrix with samples in row, features in col, first N samples are real, second N samples are generated
  # @param: log - whether the data are log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  # @param: poly - whether the features are all positive controls
  # @param: coords - coordinates data frame based on miRBase miRNA definitions
  # @param: thres - threshold for positive controls features
  if(is.null(coords)){cc <- NA}
  else{
  if(log){
    dat_combine <- 2^(dat_combine) - 1
    dat_combine[dat_combine < 0] <- 0
    dat_combine <- round(dat_combine)
  }
  
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
 if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  else if(failure == "replace"){
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  
  if(nrow(dat_combine) <= 2){cc <- NA}
  else{
    colnames(dat_generated) <- colnames(dat_real)
    rownames(dat_generated) <- rownames(dat_real)
    
    clusters <- DANA::defineClusters(genes = coords$name, chr = coords$chr, 
                                     pos = (coords$start + coords$end)/2)
    
    if(poly){posControls <- colnames(dat_combine)}
    else{
      posControls <- DANA::defineControls(raw = t(dat_real), 
                                          tZero = 2, tPoor = 10, tWell = thres,
                                          clusters = clusters)$posControls
    }
    if(!is.null(posControls)){
      invisible(capture.output(
      corPos_real <- DANA::partialCor(t(dat_real[, posControls]), scale = TRUE)))
    invisible(capture.output(
      corPos_generated <- DANA::partialCor(t(dat_generated[, posControls]), scale = TRUE)))
      cc <- compute.cc(corPos_real, corPos_generated, listClusters(as.factor(clusters)))
    }
    else{cc <- NA}
  }
  }
  return(cc)
}

summary_eval <- function(dat_combine, log = TRUE, failure= c("replace", "remove")){
  # This function compares features in generated and real dataset using mean absolute deviation on log2
  # @param: dat_combine - data matrix with samples in row, features in col, first N samples are real, second N samples are generated
  # @param: log - whether the data are log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  # @return: a list including median absolute deviation of real-generated of feature mean, var, cv, zero fraction
  if(!log){
    dat_combine <- log2(dat_combine + 1)
  }
  
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
 if(failure == "remove"){
    dat_real <- dat_real[, apply(dat_generated, 2, sd) != 0]
    dat_generated <- dat_generated[, apply(dat_generated, 2, sd) != 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  else if(failure == "replace"){
    dat_generated[ ,apply(dat_generated, 2, sd) == 0] <- dat_real[ ,apply(dat_generated, 2, sd) == 0]
    dat_combine <- rbind(dat_real, dat_generated)
  }
  if(nrow(dat_combine) <= 2){return(NA)}
  else{
    mu_generated <- apply(dat_generated, 2, mean)
    sigma_generated <- apply(dat_generated, 2, sd)
    zero_generated <- apply(dat_generated, 2, function(x){mean(x == 0)})
    cv_generated <- sigma_generated/mu_generated
    
    zero_real <- apply(dat_real, 2, function(x){mean(x == 0)})
    mu_real <- apply(dat_real, 2, mean)
    sigma_real <- apply(dat_real, 2, sd)
    cv_real <- sigma_real/mu_real
    
    ks_mean <- mad(mu_generated-mu_real)
    ks_sigma <- mad(sigma_generated-sigma_real)
    ks_zero <-mad(zero_generated-zero_real)
    ks_cv <- mad(cv_generated-cv_real)
    
    return(list(ks_mean = ks_mean, ks_sigma = ks_sigma, ks_zero = ks_zero, ks_cv = ks_cv))
  }
}

fail_features_eval <- function(dat_combine){
  # This function evaluate the generated data with respect to the failue features
  # Define the failure features to be the features with standard deviation 0
  # @param: dat_combine - data matrix with samples in row, features in col, first N samples are real, second N samples are generated
  # @return: proportion of failure features among all the features, specifially, failure genes unique in generated dataset.
  
  dat_real <- dat_combine[1:(nrow(dat_combine)/2), ]
  dat_generated <- dat_combine[(nrow(dat_combine)/2+1):nrow(dat_combine), ]
  
  
  fail_real <- apply(dat_real, 2, sd) == 0
  fail_generated <- apply(dat_generated, 2, sd) == 0
  fail_prop <- mean(apply(data.frame(fail_real = fail_real, fail_generated = fail_generated), 1, function(x){(!x['fail_real']) & x['fail_generated']}))
  return(fail_prop)
}

get_eval <- function(dataname, model_list, pilot_list, log, failure, poly, plot_first = FALSE){
  # This function conduct the DEA, clustering, DANA, summary stat evaluation
  # on the generated samples  under different models and different pilot size
  # @param: dataname - original dataset name
  # @param: model_list - a vector including all the candidates models
  # @param: pilot_list - a vector including all the candidates of pilot size
  # @param: groups - can be groups of N real samples, or groups of 2N real+generated samples
  # @param: log - whether the generated data are log2 transformed, usually TRUE
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  # @param: poly - whether the features are all positive controls, if TRUE, DANA will use all genes as positive controls
  # @param: plot_first - whether or not plot the heatmap and UMAP of the first draw
  # @return: a data frame containing evaluation results of all model and pilot size combinations
  
  # set up
  real <- paste("../RealData/", dataname, ".csv", sep = "")
  pil <- length(pilot_list)
  repli <- 5
  draw <- 5
  mod <- length(model_list)
  df_res <- data.frame(model = rep(model_list, rep(pil * repli * draw, mod)),
                       pilot_size = rep(pilot_list, rep(repli * draw, pil)),
                       replication = rep(1:(repli * draw), pil * mod),
                       ccc_log10pvalue = rep(NA, pil * repli * draw * mod),
                       ccc_log2FC = rep(NA, pil * repli * draw * mod),
                       ARI = rep(NA, pil * repli * draw * mod),
                       fail_prop = rep(NA, pil * repli * draw * mod),
                       ccc_pos = rep(NA, pil * repli * draw * mod),
                       ks_mean = rep(NA, pil * repli * draw * mod),
                       ks_sd = rep(NA, pil * repli * draw * mod),
                       ks_zero = rep(NA, pil * repli * draw * mod))
  df_res$generated_list <- paste(dataname, df_res$model, df_res$pilot_size, sep = "_")
  if(substr(dataname, 1,3) == "RNA"){coords <- NULL}
  else{coords <- read.csv("../RealData/miRBase_coords.csv")}
  # evaluation
  for ( generated in unique(df_res$generated_list)) {
    cat(generated)
    generated_info <- get_bind_list(real, generated)
    dat_combine_list <- generated_info$bind_list
    groups_all <- generated_info$groups
    samples <- generated_info$samples
    df_index_store <- data.frame(ccc_log10pvalue = rep(NA, repli * draw),
                                 ccc_log2FC = rep(NA, repli * draw),
                                 ARI = rep(NA, repli * draw),
                                 fail_prop = rep(NA, repli * draw),
                                 ccc_pos = rep(NA, repli * draw),
                                 ks_mean = rep(NA, repli * draw),
                                 ks_sd = rep(NA, repli * draw),
                                 ks_zero = rep(NA, repli * draw),
                                 ks_cv =rep(NA, repli * draw))
    for (repe in 1:(repli*draw)) {
      dat_combine <- dat_combine_list[[repe]]
      N <- nrow(dat_combine)/2
      if(is.null(groups_all)){groups <- NULL}
      else{groups <- groups_all[c(1:N, (repe * N + 1) : ((repe+1) * N))]}
      if(repe == 1 & plot_first == TRUE){
        p_heat <- heatmap_eval(dat_combine = dat_combine, 
                               main = "Real in lower panel ", log = log)
        tryCatch({ 
          p_umap <- suppressWarnings(
            UMAP_eval(dat_combine = dat_combine, groups = groups_all,
                      log = log, failure = failure))
          }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        tryCatch({print(p_umap$p_umap)}, 
                 error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        print(p_heat)
        }      
      tryCatch({ 
        df_index_store[repe, c("ccc_log10pvalue", "ccc_log2FC")] <- DEA_eval(dat_combine = dat_combine, groups = groups, log = log, failure = failure, plot = FALSE)
        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
       tryCatch({ 
      df_index_store[repe, "ARI"] <- cluster_eval(dat_combine = dat_combine, groups = groups, log = log, failure = failure, plot = FALSE)
       }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
      df_index_store[repe, "fail_prop"] <- fail_features_eval(dat_combine = dat_combine)
      tryCatch({ 
      df_index_store[repe, "ccc_pos"] <- ccpos_eval(dat_combine = dat_combine, failure = failure,
                                                    log = log, coords = coords, poly = poly,
                                                    thres = 64) 
      }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
      tryCatch({ 
      df_index_store[repe, c("ks_mean", "ks_sd", "ks_zero", "ks_cv")] <-
        unlist(suppressWarnings(summary_eval(dat_combine = dat_combine,  failure = failure, log = log)))
      }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    }
    df_res[df_res$generated_list == generated, 
           c("ccc_log10pvalue", "ccc_log2FC", "ARI", "fail_prop",
             "ccc_pos", "ks_mean", "ks_sd", "ks_zero", "ks_cv")] <- df_index_store 
  }
  return(df_res)
}

visual_eval <- function(df_res,  model_list = NULL){
  # This function help visualization of the evaluation results
  # @params: df_res - data frame containing at least pilot_size, model, 
  #                   ccc_log10pvalue, ccc_log2FC, ARI, fail_prop

    df_res$pilot_size <- factor(df_res$pilot_size, levels = pilot_list)
    df_res$model <- factor(df_res$model, levels = model_list)
    p_ccc_log10pvalue <- ggplot(data = df_res)+
                         geom_boxplot(aes(x = pilot_size, y = ccc_log10pvalue, fill = model), 
                                      show.legend = F, width = 0.6)+
                         scale_fill_brewer(palette = "PiYG")+
                         theme_bw()+
                         theme(panel.grid.major = element_blank(),
                               panel.grid.minor = element_blank())+
                         labs(x="Pilot Size", y = "CCC of -log10(p-values)")
    p_ccc_log2FC <- ggplot(data = df_res)+
                    geom_boxplot(aes(x = pilot_size, y = ccc_log2FC, fill = model), 
                                 show.legend = F, width = 0.6)+
                    scale_fill_brewer(palette = "PiYG")+
                    theme_bw()+
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank())+
                    labs(x="Pilot Size", y = "CCC of log2FC")
    p_ARI <- ggplot(data = df_res)+
             geom_boxplot(aes(x = pilot_size, y = ARI, fill = model), 
                         show.legend = F, width = 0.6)+
             theme_bw()+ 
             theme(panel.grid.major = element_blank(),
                   panel.grid.minor = element_blank())+
             scale_fill_brewer(palette = "PiYG")+
             labs(x="Pilot Size", y = "ARI/cARI of sample groups")

    p_succ_prop <- ggplot(data = df_res %>% 
                            group_by(model, pilot_size) %>% 
                            summarise(success =  1-mean(fail_prop)))+
                   geom_point(aes(x = pilot_size, y = success, color = model, group = model), 
                                show.legend = T)+
                   geom_line(aes(x = pilot_size, y = success, color = model, group = model), 
                                show.legend = F)+
                   theme_bw()+ 
                   ylim(0,1)+
                   theme(legend.position = c(0.5, 0.2))+
                   theme(panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank())+
                   scale_color_brewer(palette = "PiYG")+
                   labs(x="Pilot Size", y = "1-%(all zero genes)")
    p_ccc_pos <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ccc_pos, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "CCC of partial corr")+
                 guides(fill = guide_legend(nrow = 2, byrow = T))
    p_ks_mean <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_mean, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "MAD of feature mean")
    p_ks_sd <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_sd, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "MAD of feature sd")
    p_ks_zero <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_zero, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "MAD feature zero fraction")
    plot_grid(p_ccc_log10pvalue, p_ccc_log2FC, p_ARI, p_succ_prop, 
            p_ccc_pos, p_ks_mean, p_ks_sd, p_ks_zero, nrow = 2, ncol=4 )
}
```


# miRNA datasets evaluation

## SKCM 
```{r, SKCM - all}
dataname <- "SKCM"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("VAE1-1", "VAE1-5", "VAE1-10", "GAN", "WGAN", "WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list, log = log, 
                   failure = failure, poly = poly)
save(skcm, file = "../Results2023/SKCM.RData")
visual_eval(skcm, model_list = model_list)
```


```{r, SKCM - offline}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCM"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-1", "VAE1-5", "VAE1-10", 
                "AEhead_VAE1-1", "AEhead_VAE1-5", "AEhead_VAE1-10", 
                "GAN", "WGAN", "WGANGP",
                "AEhead_GAN", "AEhead_WGAN", "AEhead_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_AEhead <- get_eval(dataname = dataname, model_list = model_list, 
                        pilot_list = pilot_list,
                        log = log, failure = failure, poly = poly)
skcm_AEhead$offline <- sapply(skcm_AEhead$model, int_func)
skcm_AEhead$modelname <- sapply(skcm_AEhead$model, modelname_recov)
save(skcm_AEhead, file = "../Results2023/SKCM_AEhead.RData")
visual_eval(skcm_AEhead, model_list = model_list)
```


```{r, SKCM - batch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "batchup", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("50%")}
  else if (grepl( "batch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("20%")}
  else{return("10%")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCM"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","batch_VAE1-10","batchup_VAE1-10",
                "WGANGP","batch_WGANGP","batchup_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_batch <- get_eval(dataname = dataname, model_list = model_list,
                       pilot_list = pilot_list,  log = log, 
                       failure = failure, poly = poly)
skcm_batch$batch_frac <- sapply(skcm_batch$model, int_func)
skcm_batch$modelname <- sapply(skcm_batch$model, modelname_recov)
save(skcm_batch, file = "../Results2023/SKCM_Batch.RData")
visual_eval(skcm_batch, model_list = model_list)
```


```{r, SKCM - epoch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("EarlyStop")}
  else if (grepl( "epoch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Epoch=300")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCM"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","epoch_VAE1-10","epochES_VAE1-10",
                "WGANGP","epoch_WGANGP","epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_epoch <- get_eval(dataname = dataname, model_list = model_list,
                       pilot_list = pilot_list,  log = log, 
                       failure = failure, poly = poly)
skcm_epoch$epoch <- sapply(skcm_epoch$model, int_func)
skcm_epoch$modelname <- sapply(skcm_epoch$model, modelname_recov)
save(skcm_epoch, file = "../Results2023/SKCM_Epoch.RData")
visual_eval(skcm_epoch, model_list = model_list)
```


```{r, SKCM - normalization}
int_func <- function(x){
  if(grepl( "TC", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TC")}
  else if (grepl( "TMM", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TMM")}
  else if (grepl( "UQ", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("UQ")}
  else{return("None")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCM"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","TC_VAE1-10","TMM_VAE1-10","UQ_VAE1-10",
                "WGANGP","TC_WGANGP","TMM_WGANGP","UQ_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_norm <- get_eval(dataname = dataname, model_list = model_list,
                      pilot_list = pilot_list,  log = log, 
                      failure = failure, poly = poly)
skcm_norm$normalization <- sapply(skcm_norm$model, int_func)
skcm_norm$modelname <- sapply(skcm_norm$model, modelname_recov)
save(skcm_norm, file = "../Results2023/SKCM_Normalization.RData")
visual_eval(skcm_norm, model_list = model_list)
```


## SKCMPositive_4
```{r, SKCMPositive_4 - all}
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("GAN", "WGAN", "WGANGP","VAE1-1", "VAE1-5", "VAE1-10")
failure <- "remove"
log <- T
poly <- F
skcm_pos <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
save(skcm_pos, file = "../Results2023/SKCMPositive_4.RData")
visual_eval(skcm_pos, model_list = model_list)
```

```{r, SKCMPositive_4 - offline}
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 60, 100)
model_list <- c("AEhead_VAE1-1", "AEhead_VAE1-5", "AEhead_VAE1-10",
                "AEhead_GAN", "AEhead_WGAN", "AEhead_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_pos_AEhead <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
skcm_pos_AEhead$offline <- sapply(skcm_pos_AEhead$model, int_func)
skcm_pos_AEhead$modelname <- sapply(skcm_pos_AEhead$model, modelname_recov)
save(skcm_pos_AEhead, file = "../Results2023/SKCMPositive_4_AEhead.RData")
visual_eval(skcm_pos_AEhead, model_list = model_list)

```

```{r, SKCMPositive_4 - batch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "batchup", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("50%")}
  else if (grepl( "batch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("20%")}
  else{return("10%")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","batch_VAE1-10","batchup_VAE1-10",
                "WGANGP","batch_WGANGP","batchup_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_pos_batch <- get_eval(dataname = dataname, model_list = model_list,
                           pilot_list = pilot_list,  log = log, 
                           failure = failure, poly = poly)
skcm_pos_batch$batch_frac <- sapply(skcm_pos_batch$model, int_func)
skcm_pos_batch$modelname <- sapply(skcm_pos_batch$model, modelname_recov)
save(skcm_pos_batch, file = "../Results2023/SKCMPositive_4_Batch.RData")
visual_eval(skcm_pos_batch, model_list = model_list)
```


```{r, SKCMPositive_4 - epoch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("EarlyStop")}
  else if (grepl( "epoch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Epoch=300")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","epoch_VAE1-10","epochES_VAE1-10",
                "WGANGP","epoch_WGANGP","epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_pos_epoch <- get_eval(dataname = dataname, model_list = model_list,
                           pilot_list = pilot_list,  log = log, 
                           failure = failure, poly = poly)
skcm_pos_epoch$epoch <- sapply(skcm_pos_epoch$model, int_func)
skcm_pos_epoch$modelname <- sapply(skcm_pos_epoch$model, modelname_recov)
save(skcm_pos_epoch, file = "../Results2023/SKCMPositive_4_Epoch.RData")
visual_eval(skcm_pos_epoch, model_list = model_list)
```


```{r, SKCMPositive_4 - normalization}
int_func <- function(x){
  if(grepl( "TC", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TC")}
  else if (grepl( "TMM", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TMM")}
  else if (grepl( "UQ", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("UQ")}
  else{return("None")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","TC_VAE1-10","TMM_VAE1-10","UQ_VAE1-10",
                "WGANGP","TC_WGANGP","TMM_WGANGP","UQ_WGANGP")
failure <- "remove"
log <- T
poly <- F
skcm_pos_norm <- get_eval(dataname = dataname, model_list = model_list,
                      pilot_list = pilot_list,  log = log, 
                      failure = failure, poly = poly)
skcm_pos_norm$normalization <- sapply(skcm_pos_norm$model, int_func)
skcm_pos_norm$modelname <- sapply(skcm_pos_norm$model, modelname_recov)
save(skcm_pos_norm, file = "../Results2023/SKCMPositive_4_Normalization.RData")
visual_eval(skcm_pos_norm, model_list = model_list)
```


## BRCA
```{r, BRCA - all}
dataname <- "BRCA"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("VAE1-1", "VAE1-5", "VAE1-10", "GAN", "WGAN", "WGANGP")
failure <- "remove"
log <- T
poly <- F
brca <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list, log = log, 
                   failure = failure, poly = poly)
save(brca, file = "../Results2023/BRCA.RData")
visual_eval(brca, model_list = model_list)
```


```{r, BRCA - offline}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCA"
pilot_list <- c(20, 60, 100)
model_list <- c(
                #"VAE1-1", "VAE1-5", "VAE1-10", 
                #"GAN", "WGAN", "WGANGP",
                "AEhead_VAE1-1", "AEhead_VAE1-5", "AEhead_VAE1-10", 
                "AEhead_GAN", "AEhead_WGAN", "AEhead_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_AEhead <- get_eval(dataname = dataname, model_list = model_list, 
                        pilot_list = pilot_list,
                        log = log, failure = failure, poly = poly)
brca_AEhead$offline <- sapply(brca_AEhead$model, int_func)
brca_AEhead$modelname <- sapply(brca_AEhead$model, modelname_recov)
save(brca_AEhead, file = "../Results2023/BRCA_AEhead.RData")
visual_eval(brca_AEhead, model_list = model_list)
```


```{r, BRCA - batch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "batchup", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("50%")}
  else if (grepl( "batch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("20%")}
  else{return("10%")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCA"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10",
                "batch_VAE1-10","batchup_VAE1-10",
                "WGANGP",
                "batch_WGANGP","batchup_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_batch <- get_eval(dataname = dataname, model_list = model_list,
                       pilot_list = pilot_list,  log = log, 
                       failure = failure, poly = poly)
brca_batch$batch_frac <- sapply(brca_batch$model, int_func)
brca_batch$modelname <- sapply(brca_batch$model, modelname_recov)
save(brca_batch, file = "../Results2023/BRCA_Batch.RData")
visual_eval(brca_batch, model_list = model_list)
```


```{r, BRCA - epoch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("EarlyStop")}
  else if (grepl( "epoch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Epoch=300")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCA"
pilot_list <- c(20, 60, 100)
model_list <- c(#"VAE1-10",
                "epoch_VAE1-10","epochES_VAE1-10",
                #"WGANGP",
                "epoch_WGANGP","epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_epoch <- get_eval(dataname = dataname, model_list = model_list,
                       pilot_list = pilot_list,  log = log, 
                       failure = failure, poly = poly)
brca_epoch$epoch <- sapply(brca_epoch$model, int_func)
brca_epoch$modelname <- sapply(brca_epoch$model, modelname_recov)
save(brca_epoch, file = "../Results2023/BRCA_Epoch.RData")
visual_eval(brca_epoch, model_list = model_list)
```


```{r, BRCA - normalization}
int_func <- function(x){
  if(grepl( "TC", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TC")}
  else if (grepl( "TMM", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TMM")}
  else if (grepl( "UQ", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("UQ")}
  else{return("None")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCA"
pilot_list <- c(20, 60, 100)
model_list <- c(#"VAE1-10",
                "TC_VAE1-10","TMM_VAE1-10","UQ_VAE1-10",
                #"WGANGP",
                "TC_WGANGP","TMM_WGANGP","UQ_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_norm <- get_eval(dataname = dataname, model_list = model_list,
                      pilot_list = pilot_list,  log = log, 
                      failure = failure, poly = poly)
brca_norm$normalization <- sapply(brca_norm$model, int_func)
brca_norm$modelname <- sapply(brca_norm$model, modelname_recov)
save(brca_norm, file = "../Results2023/BRCA_Normalization.RData")
visual_eval(brca_norm, model_list = model_list)
```

## BRCAPositive_3
```{r, BRCAPositive_3 - all}
dataname <- "BRCAPositive_3"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("GAN", "WGAN", "WGANGP","VAE1-1", "VAE1-5", "VAE1-10")
failure <- "remove"
log <- T
poly <- F
brca_pos <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
save(brca_pos, file = "../Results2023/BRCAPositive_3.RData")
visual_eval(brca_pos, model_list = model_list)
```

```{r, BRCAPositive_3 - offline}
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCAPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("AEhead_VAE1-1", "AEhead_VAE1-5", "AEhead_VAE1-10",
                "AEhead_GAN", "AEhead_WGAN", "AEhead_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_pos_AEhead <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
brca_pos_AEhead$offline <- sapply(brca_pos_AEhead$model, int_func)
brca_pos_AEhead$modelname <- sapply(brca_pos_AEhead$model, modelname_recov)
save(brca_pos_AEhead, file = "../Results2023/BRCAPositive_3_AEhead.RData")
visual_eval(brca_pos_AEhead, model_list = model_list)

```

```{r, BRCAPositive_3 - batch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "batchup", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("50%")}
  else if (grepl( "batch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("20%")}
  else{return("10%")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCAPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","batch_VAE1-10","batchup_VAE1-10",
                "WGANGP","batch_WGANGP","batchup_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_pos_batch <- get_eval(dataname = dataname, model_list = model_list,
                           pilot_list = pilot_list,  log = log, 
                           failure = failure, poly = poly)
brca_pos_batch$batch_frac <- sapply(brca_pos_batch$model, int_func)
brca_pos_batch$modelname <- sapply(brca_pos_batch$model, modelname_recov)
save(brca_pos_batch, file = "../Results2023/BRCAPositive_3_Batch.RData")
visual_eval(brca_pos_batch, model_list = model_list)
```


```{r, BRCAPositive_3 - epoch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("EarlyStop")}
  else if (grepl( "epoch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Epoch=300")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCAPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","epoch_VAE1-10","epochES_VAE1-10",
                "WGANGP","epoch_WGANGP","epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_pos_epoch <- get_eval(dataname = dataname, model_list = model_list,
                           pilot_list = pilot_list,  log = log, 
                           failure = failure, poly = poly)
brca_pos_epoch$epoch <- sapply(brca_pos_epoch$model, int_func)
brca_pos_epoch$modelname <- sapply(brca_pos_epoch$model, modelname_recov)
save(brca_pos_epoch, file = "../Results2023/BRCAPositive_3_Epoch.RData")
visual_eval(brca_pos_epoch, model_list = model_list)
```


```{r, BRCAPositive_3 - normalization}
int_func <- function(x){
  if(grepl( "TC", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TC")}
  else if (grepl( "TMM", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TMM")}
  else if (grepl( "UQ", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("UQ")}
  else{return("None")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCAPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("VAE1-10","TC_VAE1-10","TMM_VAE1-10","UQ_VAE1-10",
                "WGANGP","TC_WGANGP","TMM_WGANGP","UQ_WGANGP")
failure <- "remove"
log <- T
poly <- F
brca_pos_norm <- get_eval(dataname = dataname, model_list = model_list,
                      pilot_list = pilot_list,  log = log, 
                      failure = failure, poly = poly)
brca_pos_norm$normalization <- sapply(brca_pos_norm$model, int_func)
brca_pos_norm$modelname <- sapply(brca_pos_norm$model, modelname_recov)
save(brca_pos_norm, file = "../Results2023/BRCAPositive_3_Normalization.RData")
visual_eval(brca_pos_norm, model_list = model_list)
```


## SKCMLAML
```{r, SKCMLAML- all}
dataname <- "SKCMLAML"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("CVAE1-1", "CVAE1-5", "CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml <- get_eval(dataname = dataname, model_list = model_list, 
                     pilot_list = pilot_list,  log = log, 
                     failure = failure, poly = poly)
save(skcmlaml, file = "../Results2023/SKCMLAML.RData")
visual_eval(skcmlaml, model_list = model_list)
```

```{r, SKCMLAML - offline}
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
dataname <- "SKCMLAML"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-1", "AEhead_CVAE1-1", "CVAE1-5", "AEhead_CVAE1-5", 
                "CVAE1-10", "AEhead_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_AEhead <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
skcmlaml_AEhead$offline <- sapply(skcmlaml_AEhead$model, int_func)
skcmlaml_AEhead$modelname <- sapply(skcmlaml_AEhead$model, modelname_recov)
save(skcmlaml_AEhead, file = "../Results2023/SKCMLAML_AEhead.RData")
visual_eval(skcmlaml_AEhead, model_list = model_list)
```


```{r, SKCMLAML - batch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "batchup", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("50%")}
  else if (grepl( "batch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("20%")}
  else{return("10%")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMLAML"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-10","batch_CVAE1-10","batchup_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_batch <- get_eval(dataname = dataname, model_list = model_list,
                               pilot_list = pilot_list,  log = log, 
                               failure = failure, poly = poly)
skcmlaml_batch$batch_frac <- sapply(skcmlaml_batch$model, int_func)
skcmlaml_batch$modelname <- sapply(skcmlaml_batch$model, modelname_recov)
save(skcmlaml_batch, file = "../Results2023/SKCMLAML_Batch.RData")
visual_eval(skcmlaml_batch, model_list = model_list)
```

```{r, SKCMLAML - epoch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("EarlyStop")}
  else if (grepl( "epoch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Epoch=300")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMLAML"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-10","epoch_CVAE1-10","epochES_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_epoch <- get_eval(dataname = dataname, model_list = model_list,
                           pilot_list = pilot_list,  log = log, 
                           failure = failure, poly = poly)
skcmlaml_epoch$epoch <- sapply(skcmlaml_epoch$model, int_func)
skcmlaml_epoch$modelname <- sapply(skcmlaml_epoch$model, modelname_recov)
save(skcmlaml_epoch, file = "../Results2023/SKCMLAML_Epoch.RData")
visual_eval(skcmlaml_epoch, model_list = model_list)
```


```{r, SKCMLMAL - normalization}
int_func <- function(x){
  if(grepl( "TC", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TC")}
  else if (grepl( "TMM", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TMM")}
  else if (grepl( "UQ", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("UQ")}
  else if (grepl( "DESeq", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("DESeq")}
  else{return("None")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMLAML"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-10","TC_CVAE1-10","TMM_CVAE1-10","UQ_CVAE1-10", "DESeq_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_norm <- get_eval(dataname = dataname, model_list = model_list,
                              pilot_list = pilot_list,  log = log, 
                              failure = failure, poly = poly)
skcmlaml_norm$normalization <- sapply(skcmlaml_norm$model, int_func)
skcmlaml_norm$modelname <- sapply(skcmlaml_norm$model, modelname_recov)
save(skcmlaml_norm, file = "../Results2023/SKCMLAML_Normalization.RData")
visual_eval(skcmlaml_norm, model_list = model_list)
```

## SKCMLAMLPositive_3

```{r, SKCMLAMLPositive_3 - all}
dataname <- "SKCMLAMLPositive_3"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("CVAE1-1", "CVAE1-5", "CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_pos <- get_eval(dataname = dataname, model_list = model_list, 
                         pilot_list = pilot_list,  log = log, 
                         failure = failure, poly = poly)
save(skcmlaml_pos, file = "../Results2023/SKCMLAMLPositive_3.RData")
visual_eval(skcmlaml_pos, model_list = model_list)
```

```{r, SKCMLAMLPositive_3 - offline}
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-1", "AEhead_CVAE1-1", "CVAE1-5", "AEhead_CVAE1-5", 
                "CVAE1-10", "AEhead_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_pos_AEhead <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
skcmlaml_pos_AEhead$offline <- sapply(skcmlaml_pos_AEhead$model, int_func)
skcmlaml_pos_AEhead$modelname <- sapply(skcmlaml_pos_AEhead$model, modelname_recov)
save(skcmlaml_pos_AEhead, file = "../Results2023/SKCMLAMLPositive_3_AEhead.RData")
visual_eval(skcmlaml_pos_AEhead, model_list = model_list)
```


```{r, SKCMLAMLPositive_3 - batch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "batchup", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("50%")}
  else if (grepl( "batch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("20%")}
  else{return("10%")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMLAMLPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-10","batch_CVAE1-10","batchup_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_pos_batch <- get_eval(dataname = dataname, model_list = model_list,
                               pilot_list = pilot_list,  log = log, 
                               failure = failure, poly = poly)
skcmlaml_pos_batch$batch_frac <- sapply(skcmlaml_pos_batch$model, int_func)
skcmlaml_pos_batch$modelname <- sapply(skcmlaml_pos_batch$model, modelname_recov)
save(skcmlaml_pos_batch, file = "../Results2023/SKCMLAMLPositive_3_Batch.RData")
visual_eval(skcmlaml_pos_batch, model_list = model_list)
```

```{r, SKCMLAMLPositive_3 - epoch}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("EarlyStop")}
  else if (grepl( "epoch", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Epoch=300")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMLAMLPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-10","epoch_CVAE1-10","epochES_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_pos_epoch <- get_eval(dataname = dataname, model_list = model_list,
                           pilot_list = pilot_list,  log = log, 
                           failure = failure, poly = poly)
skcmlaml_pos_epoch$epoch <- sapply(skcmlaml_pos_epoch$model, int_func)
skcmlaml_pos_epoch$modelname <- sapply(skcmlaml_pos_epoch$model, modelname_recov)
save(skcmlaml_pos_epoch, file = "../Results2023/SKCMLAMLPositive_3_Epoch.RData")
visual_eval(skcmlaml_pos_epoch, model_list = model_list)
```


```{r, SKCMLMALPositive_3 - normalization}
int_func <- function(x){
  if(grepl( "TC", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TC")}
  else if (grepl( "TMM", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("TMM")}
  else if (grepl( "UQ", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("UQ")}
  else if (grepl( "DESeq", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("DESeq")}
  else{return("None")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "SKCMLAMLPositive_3"
pilot_list <- c(20, 60, 100)
model_list <- c("CVAE1-10","TC_CVAE1-10","TMM_CVAE1-10","UQ_CVAE1-10", "DESeq_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
skcmlaml_pos_norm <- get_eval(dataname = dataname, model_list = model_list,
                              pilot_list = pilot_list,  log = log, 
                              failure = failure, poly = poly)
skcmlaml_pos_norm$normalization <- sapply(skcmlaml_pos_norm$model, int_func)
skcmlaml_pos_norm$modelname <- sapply(skcmlaml_pos_norm$model, modelname_recov)
save(skcmlaml_pos_norm, file = "../Results2023/SKCMLAMLPositive_3_Normalization.RData")
visual_eval(skcmlaml_pos_norm, model_list = model_list)
```
## LAMLPos/PRADPos/BRCAPRADPos optimal settings
```{r, LAMLPositive_2}
int_func <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][2],fixed = TRUE)){return("EarlyStop")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "LAMLPositive_2"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("AEhead_VAE1-10", "AEhead_epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
laml_pos_opt <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
laml_pos_opt$offline <- "AEhead"
laml_pos_opt$epoch <- sapply(laml_pos_opt$model, int_func)
laml_pos_opt$modelname <- sapply(laml_pos_opt$model, modelname_recov)
save(laml_pos_opt, file = "../Results2023/LAMLPositive_2_Optimal.RData")
visual_eval(laml_pos_opt, model_list = model_list)
```
```{r, PRADPositive_3}
int_func <- function(x){
  if(grepl( "AEhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("AEhead")}
  else{return("Original")}}
int_func2 <- function(x){
  if(grepl( "epochES", strsplit(x, "_")[[1]][2],fixed = TRUE)){return("EarlyStop")}
  else{return("Epoch=1000")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "PRADPositive_3"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("AEhead_VAE1-10", "AEhead_epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
prad_pos_opt <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
prad_pos_opt$offline <- sapply(prad_pos_opt$model, int_func)
prad_pos_opt$epoch <- sapply(prad_pos_opt$model, int_func2)
prad_pos_opt$modelname <- sapply(prad_pos_opt$model, modelname_recov)
save(prad_pos_opt, file = "../Results2023/PRADPositive_3_Optimal.RData")
visual_eval(prad_pos_opt, model_list = model_list)
```
```{r, BRCAPRADPositive_3}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][-1])
}
# run evaluation 
dataname <- "BRCAPRADPositive_3"
pilot_list <- c(20, 40, 60, 80, 100)
model_list <- c("TC_AEhead_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
brcaprad_pos_opt <- get_eval(dataname = dataname, model_list = model_list,
                            pilot_list = pilot_list,  log = log, 
                            failure = failure, poly = poly)
brcaprad_pos_opt$offline <- "AEhead"
brcaprad_pos_opt$normalization <- "TC"
brcaprad_pos_opt$modelname <- sapply(brcaprad_pos_opt$model, modelname_recov)
save(brcaprad_pos_opt, file = "../Results2023/BRCAPRADPositive_3_Optimal.RData")
visual_eval(brcaprad_pos_opt, model_list = model_list)
```




#### END of miRNA evaluation ####


## BRCA transfer
```{r, BRCA - transfer learning}
int_func <- function(x){
  if(length(strsplit(x, "_")[[1]]) == 1){return("Original")}
  else if(length(strsplit(x, "_")[[1]]) == 2){
    if(grepl( "transfrom", strsplit(x, "_")[[1]][2],fixed = TRUE)){return(strsplit(x, "_")[[1]][2])}
    else{return("Original")}}
  else if(length(strsplit(x, "_")[[1]]) == 3){
    return(strsplit(x, "_")[[1]][3])
  }
}
  
# define function to recover the model name 
modelname_recov <- function(x){
  if(grepl( "WGANGP", x, fixed = TRUE)){return("WGANGP")}
  else{return("VAE1-10")}
}
dataname <- "BRCA"
pilot_list <- c(20,  60, 100)
model_list <- c("VAE1-10", "VAE1-10_transfromPRAD",
                "VAE1-10_transfromSKCMLAMLPRAD",
                "epochES_WGANGP", "epochES_WGANGP_transfromPRAD",
                "epochES_WGANGP_transfromSKCMLAMLPRAD")
failure <- "remove"
log <- T
poly <- F
brca_transfer <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list, log = log, 
                   failure = failure, poly = poly)
brca_transfer$transfer <- sapply(brca_transfer$model, int_func)
brca_transfer$modelname <- sapply(brca_transfer$model, modelname_recov)
save(brca_transfer, file = "../Results2023/BRCA_Transfer.RData")
visual_eval(brca_transfer, model_list = model_list)
```
## SKCM transfer
```{r, SKCM - transfer learning}
int_func <- function(x){
  if(length(strsplit(x, "_")[[1]]) == 1){return("Original")}
  else if(length(strsplit(x, "_")[[1]]) == 2){
    if(grepl( "transfrom", strsplit(x, "_")[[1]][2],fixed = TRUE)){return(strsplit(x, "_")[[1]][2])}
    else{return("Original")}}
  else if(length(strsplit(x, "_")[[1]]) == 3){
    return(strsplit(x, "_")[[1]][3])
  }
}
  
# define function to recover the model name 
modelname_recov <- function(x){
  if(grepl( "WGANGP", x, fixed = TRUE)){return("WGANGP")}
  else{return("VAE1-10")}
}
dataname <- "SKCM"
pilot_list <- c(20,  60, 100)
model_list <- c("VAE1-10", "VAE1-10_transfromLAML",
                "VAE1-10_transfromLAMLBRCAPRAD",
                "epochES_WGANGP", "epochES_WGANGP_transfromLAML",
                "epochES_WGANGP_transfromLAMLBRCAPRAD")
failure <- "remove"
log <- T
poly <- F
skcm_transfer <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list, log = log, 
                   failure = failure, poly = poly)
skcm_transfer$transfer <- sapply(skcm_transfer$model, int_func)
skcm_transfer$modelname <- sapply(skcm_transfer$model, modelname_recov)
save(skcm_transfer, file = "../Results2023/SKCM_Transfer.RData")
visual_eval(skcm_transfer, model_list = model_list)
```

# RNA datasets evaluation
## RNABRCAPositive_5-2 

```{r, RNABRCAPositive_5-2 - all}
dataname <- "RNABRCAPositive_5-2"
pilot_list <- c(50, 100, 150, 200, 250)
model_list <- c("epochES_WGANGP","VAE1-100")
failure <- "remove"
log <- T
poly <- F
rnabrca_pos <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
save(rnabrca_pos, file = "../Results2023/RNABRCAPositive_5-2.RData")
visual_eval(rnabrca_pos, model_list = model_list)
```

```{r, RNABRCAPositive_5-2 - offline}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "Gaussianhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Gaussianhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][length(strsplit(x, "_")[[1]])])
}
# run evaluation 
dataname <- "RNABRCAPositive_5-2"
pilot_list <- c(50, 150, 250)
model_list <- c("Gaussianhead_VAE1-100", 
               "Gaussianhead_epochES_WGANGP",
               "epochES_WGANGP","VAE1-100")
failure <- "remove"
log <- T
poly <- F
rnabrca_pos_Gaussianhead <- get_eval(dataname = dataname, model_list = model_list, 
                        pilot_list = pilot_list,
                        log = log, failure = failure, poly = poly)
rnabrca_pos_Gaussianhead <- rbind(rnabrca_Gaussianhead, rnabrca_pos)
rnabrca_pos_Gaussianhead$offline <- sapply(rnabrca_pos_Gaussianhead$model, int_func)
rnabrca_pos_Gaussianhead$modelname <- sapply(rnabrca_pos_Gaussianhead$model, modelname_recov)
save(rnabrca_pos_Gaussianhead, file = "../Results2023/RNABRCAPositive_5-2_Gaussianhead.RData")
visual_eval(rnabrca_pos_Gaussianhead, model_list = model_list)
```


## RNAPRADPositive_5-2 
```{r, RNAPRADPositive_5-2 - all}
dataname <- "RNAPRADPositive_5-2"
pilot_list <- c(50, 100, 150, 200, 250)
model_list <- c("epochES_WGANGP","VAE1-100")
failure <- "remove"
log <- T
poly <- F
rnaprad_pos <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
save(rnaprad_pos, file = "../Results2023/RNAPRADPositive_5-2.RData")
visual_eval(rnaprad_pos, model_list = model_list)
```

```{r, RNAPRADPositive_5-2 - offline}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "Gaussianhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Gaussianhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][length(strsplit(x, "_")[[1]])])
}
# run evaluation 
dataname <- "RNAPRADPositive_5-2"
pilot_list <- c(50, 150, 250)
model_list <- c("VAE1-100", "Gaussianhead_VAE1-100", 
               "epochES_WGANGP", "Gaussianhead_epochES_WGANGP")
failure <- "remove"
log <- T
poly <- F
rnaprad_pos_Gaussianhead <- get_eval(dataname = dataname, model_list = model_list, 
                        pilot_list = pilot_list,
                        log = log, failure = failure, poly = poly)
rnaprad_pos_Gaussianhead$offline <- sapply(rnaprad_pos_Gaussianhead$model, int_func)
rnaprad_pos_Gaussianhead$modelname <- sapply(rnaprad_pos_Gaussianhead$model, modelname_recov)
save(rnaprad_pos_Gaussianhead, file = "../Results2023/RNAPRADPositive_5-2_Gaussianhead.RData")
visual_eval(rnaprad_pos_Gaussianhead, model_list = model_list)
```




## RNABRCAPRADPositive_5-2
```{r, RNABRCAPRADPositive_5-2 - all}
dataname <- "RNABRCAPRADPositive_5-2"
pilot_list <- c(50, 100, 150, 200, 250)
model_list <- c("CVAE1-100")
failure <- "remove"
log <- T
poly <- F
rnabrcaprad_pos <- get_eval(dataname = dataname, model_list = model_list, 
                     pilot_list = pilot_list,  log = log, 
                     failure = failure, poly = poly)
save(rnabrcaprad_pos, file = "../Results2023/RNABRCAPRADPositive_5-2.RData")
visual_eval(rnabrcaprad_pos, model_list = model_list)
```

```{r, RNABRCAPRADPositive_5-2 - offline}
# define function to extract the interested factor from model name
int_func <- function(x){
  if(grepl( "Gaussianhead", strsplit(x, "_")[[1]][1],fixed = TRUE)){return("Gaussianhead")}
  else{return("Original")}}
# define function to recover the model name 
modelname_recov <- function(x){
  ifelse(length(strsplit(x, "_")[[1]]) == 1, x, strsplit(x, "_")[[1]][length(strsplit(x, "_")[[1]])])
}
# run evaluation 
dataname <- "RNABRCAPRADPositive_5-2"
pilot_list <- c(50, 150, 250)
model_list <- c("CVAE1-100", "Gaussianhead_CVAE1-100")
failure <- "remove"
log <- T
poly <- F
rnabrcaprad_pos_Gaussianhead <- get_eval(dataname = dataname, model_list = model_list, 
                        pilot_list = pilot_list,
                        log = log, failure = failure, poly = poly)
rnabrcaprad_pos_Gaussianhead$offline <- sapply(rnabrcaprad_pos_Gaussianhead$model, int_func)
rnabrcaprad_pos_Gaussianhead$modelname <- sapply(rnabrcaprad_pos_Gaussianhead$model, modelname_recov)
save(rnabrcaprad_pos_Gaussianhead, file = "../Results2023/RNABRCAPRADPositive_5-2_Gaussianhead.RData")
visual_eval(rnabrcaprad_pos_Gaussianhead, model_list = model_list)
```


## RNABRCASPLIT Transfer
```{r, RNABRCASPLIT - transfer learning}
int_func <- function(x){
  if(length(strsplit(x, "_")[[1]]) == 1){return("Original")}
  else if(length(strsplit(x, "_")[[1]]) == 2){
    if(grepl( "transfrom", strsplit(x, "_")[[1]][2],fixed = TRUE)){return("Transfer")}
    else{return("Original")}}
  else if(length(strsplit(x, "_")[[1]]) == 3){
    return(return("Transfer"))
  }
}
  
# define function to recover the model name 
modelname_recov <- function(x){
  if(grepl("WGANGP", x, fixed = TRUE)){return("WGANGP")}
  else{return("VAE1-100")}
}

dataname <- "RNABRCASPLIT"
pilot_list <- c(50, 150, 250)
model_list <- c("VAE1-100","VAE1-100_transfromRNAPRADSPLIT")
failure <- "remove"
log <- T
poly <- F
rnabrca_transfer <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list, log = log, 
                   failure = failure, poly = poly)
rnabrca_transfer$transfer <- sapply(rnabrca_transfer$model, int_func)
rnabrca_transfer$modelname <- sapply(rnabrca_transfer$model, modelname_recov)
save(rnabrca_transfer, file = "../Results2023/RNABRCASPLIT_Transfer.RData")
visual_eval(rnabrca_transfer, model_list = model_list)
```
## RNAPRADSPLIT Transfer
```{r, RNAPRADSPLIT - transfer learning}
int_func <- function(x){
  if(length(strsplit(x, "_")[[1]]) == 1){return("Original")}
  else if(length(strsplit(x, "_")[[1]]) == 2){
    if(grepl( "transfrom", strsplit(x, "_")[[1]][2],fixed = TRUE)){return("Transfer")}
    else{return("Original")}}
  else if(length(strsplit(x, "_")[[1]]) == 3){
    return(return("Transfer"))
  }
}
  
# define function to recover the model name 
modelname_recov <- function(x){
  if(grepl("WGANGP", x, fixed = TRUE)){return("WGANGP")}
  else{return("VAE1-100")}
}
dataname <- "RNAPRADSPLIT"
pilot_list <- c(50, 150, 250)
model_list <- c("VAE1-100", "VAE1-100_transfromRNABRCASPLIT")
failure <- "remove"
log <- T
poly <- F
rnaprad_transfer <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list, log = log, 
                   failure = failure, poly = poly)
rnaprad_transfer$transfer <- sapply(rnaprad_transfer$model, int_func)
rnaprad_transfer$modelname <- sapply(rnaprad_transfer$model, modelname_recov)
save(rnaprad_transfer, file = "../Results2023/RNAPRADSPLIT_Transfer.RData")
visual_eval(rnaprad_transfer, model_list = model_list)
```

# Just for record, DO NOT USE
```{r, eval = FALSE, echo = F}
get_eval_RNA <- function(dataname, model_list, pilot_list, log, failure, plot_first = FALSE){
  # This function conduct the evaluation on the generated RNA seq samples 
  # under different models and different pilot size
  # @param: dataname - original dataset name, should be ACCPositive_12
  # @param: model_list - a vector including all the candidates models
  # @param: pilot_list - a vector including all the candidates of pilot size
  # @param: groups - can be groups of N real samples, or groups of 2N real+generated samples
  # @param: log - whether the generated data are log2 transformed
  # @param: failure -  how to deal with failure genes "replace" replace the zero features in generated data with the real ones, "remove"  remove the failure genes in evaluation
  # @param: plot_first - whether or not plot the heatmap and UMAP of the first draw
  # @return: a data frame containing evaluation results of all model and pilot size combinations
  
  # set up
  real <- paste("../RealData/", dataname, ".csv", sep = "")
  pil <- length(pilot_list)
  repli <- 5
  draw <- 5
  mod <- length(model_list)
  df_res <- data.frame(model = rep(model_list, rep(pil * repli * draw, mod)),
                       pilot_size = rep(pilot_list, rep(repli * draw, pil)),
                       replication = rep(1:(repli * draw), pil * mod),
                       ARI = rep(NA, pil * repli * draw * mod),
                       fail_prop = rep(NA, pil * repli * draw * mod),
                       ks_mean = rep(NA, pil * repli * draw * mod),
                       ks_sd = rep(NA, pil * repli * draw * mod))
  df_res$generated_list <- paste(dataname, df_res$model, df_res$pilot_size, sep = "_")
  # evaluation
  for (generated in unique(df_res$generated_list)) {
    cat(generated)
    generated_info <- get_bind_list(real, generated, real_log = F, generated_log = log)
    dat_combine_list <- generated_info$bind_list
    groups_all <- generated_info$groups
    samples <- generated_info$samples
    df_index_store <- data.frame(ARI = rep(NA, repli * draw),
                                 fail_prop = rep(NA, repli * draw),
                                 ks_mean = rep(NA, repli * draw),
                                 ks_sd = rep(NA, repli * draw))
    for (repe in 1:(repli*draw)) {
      dat_combine <- dat_combine_list[[repe]]
      N <- nrow(dat_combine)/2
      if(is.null(groups_all)){groups <- NULL}
      else{groups <- groups_all[c(1:N, (repe * N + 1) : ((repe+1) * N))]}
      if(repe == 1 & plot_first == TRUE){
        p_heat <- heatmap_eval(dat_combine = dat_combine, 
                               main = "Real in lower panel ", log = log)
        tryCatch({ 
          p_umap <- suppressWarnings(
            UMAP_eval(dat_combine = dat_combine, groups = groups_all,
                      log = log, failure = failure))
          }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        tryCatch({print(p_umap$p_umap)}, 
                 error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        print(p_heat)
        }
      tryCatch({ 
      df_index_store[repe, "ARI"] <- cluster_eval(dat_combine = dat_combine, groups = groups, log = log, failure = failure, plot = FALSE)
       }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
      df_index_store[repe, "fail_prop"] <- fail_features_eval(dat_combine = dat_combine)
      tryCatch({ 
      df_index_store[repe, c("ks_mean", "ks_sd")] <-
        unlist(suppressWarnings(summary_eval(dat_combine = dat_combine,  
                                             failure = failure, log = log)))[c("ks_mean", "ks_sigma")]
      }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    }
    df_res[df_res$generated_list == generated, 
           c("ARI", "fail_prop","ks_mean", "ks_sd")] <- df_index_store 
  }
  return(df_res)
}
```



```{r, eval=FALSE}
visual_eval <- function(df_res, df_res_2 = NULL, model_list = NULL){
  # This function help visualization of the evaluation results
  # @params: df_res - data frame containing at least pilot_size, model, 
  #                   ccc_log10pvalue, ccc_log2FC, ARI, fail_prop
  # @params: df_res_2 - data frame containing offline_augmentation results
  if(is.null(df_res_2)){
    if(is.null(model_list)){model_list <-  c("VAE1-1", "VAE1-5", "VAE1-10", "GAN", "WGAN", "WGANGP")}
    df_res$pilot_size <- factor(df_res$pilot_size, levels = pilot_list)
    df_res$model <- factor(df_res$model, levels = model_list)
    p_ccc_log10pvalue <- ggplot(data = df_res)+
                         geom_boxplot(aes(x = pilot_size, y = abs(ccc_log10pvalue), fill = model), 
                                      show.legend = F, width = 0.6)+
                         scale_fill_brewer(palette = "PiYG")+
                         theme_bw()+
                         theme(panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank())+
                         labs(x="Pilot Size", y = "Concordance of -log10(p-values)")+
                         #theme(legend.position = c(0.5, 0.78))+
                         guides(fill = guide_legend(nrow = 2, byrow = T))
    p_ccc_log2FC <- ggplot(data =  df_res)+
                    geom_boxplot(aes(x = pilot_size, y = abs(ccc_log2FC), fill = model), 
                                 show.legend = F, width = 0.6)+
                    scale_fill_brewer(palette = "PiYG")+
                    theme_bw()+
                    theme(panel.grid.major = element_blank(),
                    panel.grid.minor = element_blank())+
                    labs(x="Pilot Size", y = "Concordance of log2FC")
    p_ARI <- ggplot(data = df_res)+
             geom_boxplot(aes(x = pilot_size, y = abs(ARI), fill = model), 
                         show.legend = F, width = 0.6)+
             theme(legend.position = "bottom")+
             theme_bw()+ 
             theme(panel.grid.major = element_blank(),
                   panel.grid.minor = element_blank())+
             scale_fill_brewer(palette = "PiYG")+
             labs(x="Pilot Size", y = "ARI")

    p_succ_prop <- ggplot(data = df_res %>% 
                            group_by(model, pilot_size) %>% 
                            summarise(success =  1-mean(fail_prop)))+
                   geom_point(aes(x = pilot_size, y = success, color = model, group = model), 
                                show.legend = T)+
                   geom_line(aes(x = pilot_size, y = success, color = model, group = model), 
                                show.legend = F)+
                   theme_bw()+ 
                   ylim(0,1)+
                   theme(legend.position = c(0.5, 0.2))+
                   theme(panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank())+
                   scale_color_brewer(palette = "PiYG")+
                   labs(x="Pilot Size", y = "Proportion of Successful Features")
    p_ccc_pos <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ccc_pos, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Concordance of partial corr for positive controls")+
                 guides(fill = guide_legend(nrow = 2, byrow = T))
    
    p_ks_mean <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_mean, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity of feature-wise mean")+
                 guides(fill = guide_legend(nrow = 2, byrow = T))
    p_ks_sd <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_sd, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity of feature-wise sd")+
                 guides(fill = guide_legend(nrow = 2, byrow = T))
    p_ks_zero <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_zero, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity of feature-wise zero fraction")+
                 guides(fill = guide_legend(nrow = 2, byrow = T))
    p_ks_cv <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ks_cv, fill = model),
                              show.legend = F, width = 0.6)+
                 scale_fill_brewer(palette = "PiYG")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity of feature-wise coefficient of variation")+
                 guides(fill = guide_legend(nrow = 2, byrow = T))
    plot_grid(p_ccc_log10pvalue, p_ccc_log2FC, p_ARI, p_succ_prop, 
            p_ccc_pos, p_ks_mean, p_ks_sd, p_ks_zero, nrow = 2, ncol=4 )
  }
  else{
    if(is.null(model_list)){
    model_list <-  c("VAE1-1", "AEhead_VAE1-1", 
                     "VAE1-5", "AEhead_VAE1-5",
                     "VAE1-10", "AEhead_VAE1-10",
                     "GAN", "AEhead_GAN", 
                     "WGAN", "AEhead_WGAN", 
                     "WGANGP", "AEhead_WGANGP")}
    df_res <- as.data.frame(rbind(df_res, df_res_2))
    df_res$modeltype <- factor(sapply(df_res$model, 
                                      function(x){y <- strsplit(x, "_")[[1]]
                                      if(length(y) > 1){return(y[2])} else{return(y[1])}}),
                               levels = model_list[seq(1, length(model_list), 2)]
                               ) 
                               #levels = c("VAE1-1", "VAE1-5", "VAE1-10", "GAN", "WGAN", "WGANGP"))
    df_res$pilot_size <- factor(df_res$pilot_size, levels = pilot_list)
    df_res$AEhead <- ifelse(substr(df_res$model, 1, 6) == "AEhead", "With_AE", "Without_AE")
    df_res$model <- factor(df_res$model, levels = model_list)
    p_ccc_log10pvalue <- ggplot(data = df_res)+
                         geom_boxplot(aes(x = pilot_size, y = abs(ccc_log10pvalue), fill = AEhead), 
                                      show.legend = F, width = 0.6)+
                         facet_wrap(vars(modeltype), scales = "free_y")+
                         theme_bw()+
                         theme(panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank())+
                         labs(x="Pilot Size", y = "Concordance of -log10(p-values)") 
    p_ccc_log2FC <- ggplot(data =  df_res)+
                    geom_boxplot(aes(x = pilot_size, y = abs(ccc_log2FC), fill = AEhead), 
                                 show.legend = F, width = 0.6)+
                    facet_wrap(vars(modeltype), scales = "free_y")+
                    theme_bw()+
                    theme(panel.grid.major = element_blank(),
                    panel.grid.minor = element_blank())+
                    labs(x="Pilot Size", y = "Concordance of log2FC")
    p_ARI <- ggplot(data = df_res)+
             geom_boxplot(aes(x = pilot_size, y = abs(ARI), fill = AEhead), 
                         show.legend = F, width = 0.6)+
             theme_bw()+ 
             facet_wrap(vars(modeltype), scales = "free_y")+
             theme(panel.grid.major = element_blank(),
                   panel.grid.minor = element_blank())+
             labs(x="Pilot Size", y = "ARI")

    p_succ_prop <- ggplot(data = df_res %>% 
                            group_by(modeltype, AEhead, pilot_size) %>% 
                            summarise(success =  1-mean(fail_prop)))+
                   geom_point(aes(x = pilot_size, y = success, color = AEhead,  group = AEhead), 
                                show.legend = T)+
                   geom_line(aes(x = pilot_size, y = success, color = AEhead, group = AEhead), 
                                show.legend = T)+
                   facet_wrap(vars(modeltype),)+
                   theme_bw()+ 
                   theme(panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank())+
                   labs(x="Pilot Size", y = "Proportion of Successful Features")+
                   theme(legend.position = c(0.7, 0.2),
                         legend.title = element_blank())+
                   guides(color = guide_legend(nrow = 1, byrow = T))
    p_ccc_pos <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = ccc_pos, fill = AEhead),
                              show.legend = F, width = 0.6)+
                 facet_wrap(vars(modeltype), scales = "free_y")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Concordance of partial corr for positive controls") 
    p_ks_mean <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = 1/ks_mean, fill = AEhead),
                              show.legend = F, width = 0.6)+
                 facet_wrap(vars(modeltype), scales = "free_y")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity of feature-wise mean")
    p_ks_sd <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = 1/ks_sd, fill = AEhead),
                              show.legend = F, width = 0.6)+
                 facet_wrap(vars(modeltype), scales = "free_y")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity of  feature-wise sd") 
    p_ks_zero <- ggplot(data = df_res)+
                 geom_boxplot(aes(x = pilot_size, y = 1/ks_zero, fill = AEhead),
                              show.legend = F, width = 0.6)+
                 facet_wrap(vars(modeltype), scales = "free_y")+
                 theme_bw()+
                 theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank())+
                 labs(x="Pilot Size", y = "Similarity offeature-wise zero fraction")
    plot_grid(p_ccc_log10pvalue, p_ccc_log2FC, p_ARI, p_succ_prop, 
            p_ccc_pos, p_ks_mean, p_ks_sd, p_ks_zero, nrow = 4, ncol=2 )
  }

}
```
```{r, settings using SKCM, comparision of normalization method, with AEhead}
dataname_set <- c("SKCM")
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("AEhead_TC_VAE1-10","AEhead_TMM_VAE1-10","AEhead_UQ_VAE1-10")
failure <- "remove"
log <- T
poly <- F
df_res_norm_AE <- data.frame(Normalization = rep(c("None", "PoissonSeq", "UQ", "TMM"), rep(5 * 5 * length(pilot_list))))
for (dataname in dataname_set) {
  norm <- substr(dataname, 6, nchar(dataname))
  if(norm == ""){ norm = "None"}
  df_res <- get_eval(dataname = dataname, model_list = model_list,
                          pilot_list = pilot_list,  log = log, 
                          failure = failure, poly = poly)
  df_res_norm_AE[df_res_norm_AE$Normalization == norm, 2:(ncol(df_res)+1)] <- df_res
  print(df_res_norm_AE)
}

df_res <- tidyr::pivot_longer(df_res_norm_AE, cols=c(5:12,14), names_to = "Type", values_to = "Rate")
ggplot(data = df_res)+
  geom_boxplot(aes(x = factor(pilot_size), y = Rate, fill = factor(Normalization, levels = c("None", "TMM","UQ","PoissonSeq"))))+
  labs(fill="Norm")+
  facet_wrap(vars(Type),nrow = 2, scales = "free_y")


```
```{r, settings using SKCMLAML with positive controls dataset with AE head}
dataname <- "SKCMLAMLPositive_3"
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("AEhead_CVAE1-1", "AEhead_CVAE1-5", "AEhead_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
load("../Results/SKCMLAMLPositive_3_dfres_CVAEs.rda")
df_res_AE <- get_eval(dataname = dataname, model_list = model_list,
                      pilot_list = pilot_list,  log = log, 
                      failure = failure, poly = poly)
visual_eval(df_res = df_res_AE, model_list = model_list)
visual_eval(df_res = df_res_NoAE, df_res_2 = df_res_AE,
            model_list = c("CVAE1-1", "AEhead_CVAE1-1", "CVAE1-5", "AEhead_CVAE1-5",
                           "CVAE1-10","AEhead_CVAE1-10"))
```

```{r, settings using SKCMLMAL with positive controls, comparision of normalization method}
dataname_set <- c("SKCMLAMLPositive_3", "SKCMLAMLPositive_3_DESeq",
              "SKCMLAMLPositive_3_PoissonSeq", "SKCMLAMLPositive_3_RUVr",
              "SKCMLAMLPositive_3_TMM")
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("CVAE1-10")
failure <- "remove"
log <- T
poly <- F
df_res_norm <- data.frame(Normalization = rep(c("None", "DESeq", "PoissonSeq", "RUVr", "TMM"), rep(5 * 5 * length(pilot_list))))
for (dataname in dataname_set) {
  norm <- substr(dataname, 20, nchar(dataname))
  if(norm == ""){ norm = "None"}
  df_res <- get_eval(dataname = dataname, model_list = model_list,
                          pilot_list = pilot_list,  log = log, 
                          failure = failure, poly = poly)
  df_res_norm[df_res_norm$Normalization == norm, 2:(ncol(df_res)+1)] <- df_res
}

df_res <- tidyr::pivot_longer(df_res_norm, cols=c(5:12,14), names_to = "Type", values_to = "Rate")
ggplot(data = df_res)+
  geom_boxplot(aes(x = factor(pilot_size), y = Rate, fill = factor(Normalization, levels = c("None", "TMM","DESeq","PoissonSeq","RUVr"))))+
  labs(fill="Norm")+
  facet_wrap(vars(Type),nrow = 2)


```

```{r, settings using SKCMLMAL with positive controls, comparision of normalization method, with AEhead}
dataname_set <- c("SKCMLAMLPositive_3", "SKCMLAMLPositive_3_DESeq",
              "SKCMLAMLPositive_3_PoissonSeq", "SKCMLAMLPositive_3_RUVr",
              "SKCMLAMLPositive_3_TMM")
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("AEhead_CVAE1-10")
failure <- "remove"
log <- T
poly <- F
df_res_norm_AE <- data.frame(Normalization = rep(c("None", "DESeq", "PoissonSeq", "RUVr", "TMM"), rep(5 * 5 * length(pilot_list))))
for (dataname in dataname_set) {
  norm <- substr(dataname, 20, nchar(dataname))
  if(norm == ""){ norm = "None"}
  df_res <- get_eval(dataname = dataname, model_list = model_list,
                          pilot_list = pilot_list,  log = log, 
                          failure = failure, poly = poly)
  df_res_norm_AE[df_res_norm_AE$Normalization == norm, 2:(ncol(df_res)+1)] <- df_res
}

df_res <- tidyr::pivot_longer(df_res_norm_AE, cols=c(5:12,14), names_to = "Type", values_to = "Rate")
ggplot(data = df_res)+
  geom_boxplot(aes(x = factor(pilot_size), y = Rate, fill = factor(Normalization, levels = c("None", "TMM","DESeq","PoissonSeq","RUVr"))))+
  labs(fill="Norm")+
  facet_wrap(vars(Type),nrow = 2)


```


```{r, settings using BRCAPRAD with positive controls dataset}
dataname <- "BRCAPRADPositive_3"
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("CVAE1-1", "CVAE1-5", "CVAE1-10")
failure <- "remove"
log <- T
poly <- F
df_res_NoAE <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
visual_eval(df_res_NoAE, model_list = model_list)
```


```{r, settings using SKCM with positive controls dataset comparision of batch size}
# change the draw_path in get_bind_list to _batch.csv for 20%, and _batchdown.csv for 5% and _batchup.csv for 50%
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("VAE1-10")
failure <- "remove"
log <- T
poly <- F
df_res_batch005 <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
df_res_batch <- as.data.frame(rbind(df_res_batch005, df_res_batch01, df_res_batch02))
df_res_batch$batchfrac <- factor(rep(c("5%","10%","20%"), c(nrow(df_res_batch005), nrow(df_res_batch01), nrow(df_res_batch02))), levels = c("5%","10%","20%"))
```


```{r, settings using SKCM with positive controls dataset comparision of epochs}
# change the draw_path in get_bind_list to _epoch.csv for 300epochs, _epochES.csv for early stopping with 30 rounds 
dataname <- "SKCMPositive_4"
pilot_list <- c(20, 40, 60, 80, 100, 150)
model_list <- c("VAE1-10")
failure <- "remove"
log <- T
poly <- F
df_res_epochES <- get_eval(dataname = dataname, model_list = model_list, 
                   pilot_list = pilot_list,  log = log, 
                   failure = failure, poly = poly)
df_res_epochES$epoch <- "early_stop"
df_res_epoch <- as.data.frame(rbind(df_res_epoch, df_res_epochES))
df_res_epoch$epoch <- factor(df_res_epoch$epoch, levels = c("300","1000",'early_stop'))
```


```{r, settings using ACCPositive_12 for model comparision}
# fixed off_aug = 9, batch_frac = 0.1, learning rate 0.0005
dataname <- "ACCPositive_12"
pilot_list <- c(20, 30, 40, 50, 60, 70)
model_list <- c("VAE1-10", "VAE1-100","VAE1-200", "GAN", "WGAN", "WGANGP")
failure <- "remove"
log <- T
df_res <- get_eval_RNA(dataname = dataname, model_list = model_list, 
                       pilot_list = pilot_list,  log = log, 
                       failure = failure, plot_first = FALSE)
# visualization
res <- df_acc[,c("model", "pilot_size", "ARI", "fail_prop", "ks_mean","ks_sd")]
res$succ_prop <- 1 - res$fail_prop
res <- tidyr::pivot_longer(res, cols = c("ARI", "succ_prop"), names_to = "Metric", values_to = "Rate")
res$pilot_size <- factor(res$pilot_size, levels = c("20", "30", "40", "50", "60", "70"))
res$model <- factor(res$model, levels = c("VAE1-10", "VAE1-100","VAE1-200", "GAN", "WGAN", "WGANGP"))
res$Metric <- factor(res$Metric, levels = c("succ_prop","ARI"),
                     labels = c("Proportion of Successful Genes", 
                                "Adjusted Rand Index"))
res$modeltype <- rep(NA, nrow(res))
for (i in 1:nrow(res)) {
  if(substr(res$model[i], 1,3)=="VAE"){res$modeltype[i] <- "VAEs"}
  else if(substr(res$model[i], 1,3) %in% c("GAN", "WGA")){res$modeltype[i] <- "GANs"}
  else{res$modeltype[i] <- "FLOWs"}
}
res$modeltype <- factor(res$modeltype, levels = c("VAEs","FLOWs","GANs"))
ggplot(data = res)+ 
  geom_boxplot(aes(x = pilot_size, y = Rate, fill = model), show.legend = T, width = 0.6)+
  # facet_nested(Metric~Dataset+modeltype)+
  facet_grid(row=vars(Metric), col=vars(modeltype), switch = "y", scales = "free_y")+
  theme_bw()+
  labs(x="Pilot size", y="", switch = "y")+
  scale_y_continuous(position = "left",limits  = c(0,1))+
  theme(legend.position = "bottom")+
  labs(fill = "Models")+
  guides(fill=guide_legend(nrow=1,byrow=TRUE))+
  scale_fill_manual(values = mycolors)

res <- df_acc[,c("model","pilot_size","ks_mean","ks_sd")]
res$model <- factor(res$model, levels = c("VAE1-10", "VAE1-100","VAE1-200", "GAN", "WGAN", "WGANGP"))

res <- res %>% group_by(pilot_size, model) %>%
  summarise(
    Mean = mean(ks_mean),
    Sd = mean(ks_sd)
  )

res <- tidyr::pivot_longer(res, cols = c("Mean", "Sd"), names_to = "Metric", values_to = "Rate")
res$pilot_size <- factor(res$pilot_size, levels = c("20", "30", "40", "50", "60", "70"))
res$Metric <- factor(res$Metric, levels = rev(c("Mean", "Sd")))
res$text <- round(res$Rate,3)
res$text[is.na(res$Rate)] <- "NA"
res$Rate[is.na(res$Rate)] <- 3
ggplot(res,aes(x = pilot_size , y = Metric, fill = Rate),) + 
  geom_tile(show.legend = T)+
  labs(fill = "MAD")+
  labs(y="",x="")+
  facet_wrap(vars(model),dir="v")+
  geom_text(aes(pilot_size, Metric, label = text), color = "black", size = 4) +
  theme_minimal()+
  scale_fill_gradientn(colours = terrain.colors(10))+
  theme(axis.text.y = element_text(angle = 0, hjust = 1, colour = "black",size = 10))+
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_blank())+
  theme(legend.position = "bottom")+
  scale_y_discrete(labels=c( "Sd" = "SD",
                            "Mean" = "Mean"))
```



```{r, settings using ACCPositive_12 for normalization comparision}
# fixed off_aug = 9, batch_frac = 0.1, learning rate 0.0005
dataname_set <- c("ACCPositive_12", "ACCPositive_12_TC",
                  "ACCPositive_12_TMM", "ACCPositive_12_UQ")
pilot_list <- c(20, 30, 40, 50, 60, 70)
model_list <- c("VAE1-100")
failure <- "remove"
log <- T
df_acc_norm <- data.frame(Normalization = rep(c("None", "TC", "UQ", "TMM"), 
                                              rep(5 * 5 * length(pilot_list))))
for (dataname in dataname_set) {
  norm <- substr(dataname, 16, nchar(dataname))
  if(norm == ""){ norm = "None"}
  df_res <- get_eval_RNA(dataname = dataname, model_list = model_list,
                         pilot_list = pilot_list,  log = log, failure = failure)
  df_acc_norm[df_acc_norm$Normalization == norm, 2:(ncol(df_res)+1)] <- df_res
  print(df_acc_norm)
}
df_acc_norm$succ_prop <- 1 - df_acc_norm$fail_prop

df_res <- tidyr::pivot_longer(df_acc_norm, cols=c(5,10), names_to = "Type", values_to = "Rate")

ggplot(data = df_res)+
  geom_boxplot(aes(x = factor(pilot_size), y = Rate, fill = factor(Normalization, levels = c("None", "TC","UQ","TMM"))))+
  labs(fill="Norm")+
  facet_wrap(vars(Type),nrow = 2, scales = "free_y")+
  theme_bw()+
  labs(x="Pilot size", y="", switch = "y")+
  scale_y_continuous(position = "left",limits  = c(0,1))+
  theme(legend.position = "bottom")+
  guides(fill=guide_legend(nrow=1,byrow=TRUE))

res <- df_acc_norm[,c("model","pilot_size","ks_mean","ks_sd","Normalization")]


res <- res %>% group_by(pilot_size, Normalization) %>%
  summarise(
    Mean = mean(ks_mean),
    Sd = mean(ks_sd)
  )

res <- tidyr::pivot_longer(res, cols = c("Mean", "Sd"), names_to = "Metric", values_to = "Rate")
res$pilot_size <- factor(res$pilot_size, levels = c("20", "30", "40", "50", "60", "70"))
res$Metric <- factor(res$Metric, levels = rev(c("Mean", "Sd")))
res$text <- round(res$Rate,3)
res$text[is.na(res$Rate)] <- "NA"
res$Rate[is.na(res$Rate)] <- 3
ggplot(res,aes(x = pilot_size , y = Metric, fill = Rate),) + 
  geom_tile(show.legend = T)+
  labs(fill = "MAD")+
  labs(y="",x="")+
  facet_wrap(vars(Normalization),dir="v")+
  geom_text(aes(pilot_size, Metric, label = text), color = "black", size = 4) +
  theme_minimal()+
  scale_fill_gradientn(colours = terrain.colors(10))+
  theme(axis.text.y = element_text(angle = 0, hjust = 1, colour = "black",size = 10))+
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_blank())+
  theme(legend.position = "bottom")+
  scale_y_discrete(labels=c( "Sd" = "SD",
                            "Mean" = "Mean"))
```

```{r, settings using ACCPositive_12 for off_aug comparision}
# fixed off_aug = 9, batch_frac = 0.1, learning rate 0.0005
dataname_set <- c("ACCPositive_12_offnone", "ACCPositive_12_offdown", "ACCPositive_12")
pilot_list <- c(20, 30, 40, 50, 60, 70)
model_list <- c("VAE1-100")
failure <- "remove"
log <- T
level_names <- c("None", "4 Times", "10 Times")
df_res_off <- data.frame(off_aug = rep(c("None", "4 Times", "10 Times"),
                                       rep(5 * 5 * length(pilot_list))))
for (dat_ind in 1:length(dataname_set)) {
  dataname <- dataname_set[dat_ind]
  level_name <- level_names[dat_ind]
  df_res <- get_eval_RNA(dataname = dataname, model_list = model_list,
                         pilot_list = pilot_list,  log = log, failure = failure)
  df_res$off_aug = "None"
  df_acc_aug = as.data.frame(rbind(df_acc_aug, df_res))
  df_res_off[df_res_off$off_aug == level_name, 2:(ncol(df_res)+1)] <- df_res
  print(df_res_off)
}

df_res$succ_prop <- 1 - df_res$fail_prop

df_res <- tidyr::pivot_longer(df_acc_aug, cols=c(5,10), names_to = "Type", values_to = "Rate")

ggplot(data = df_res)+
  geom_boxplot(aes(x = factor(pilot_size), y = Rate, fill = factor(off_aug, levels = c("None", "4 Times", "10 Times"))))+
  labs(fill="Offline-augmentation multiplier")+
  facet_wrap(vars(Type),nrow = 2, scales = "free_y")+
  theme_bw()+
  labs(x="Pilot size", y="", switch = "y")+
  scale_y_continuous(position = "left",limits  = c(0,1))+
  theme(legend.position = "bottom")+
  guides(fill=guide_legend(nrow=1,byrow=TRUE))

res <- df_acc_aug[,c("model","pilot_size","ks_mean","ks_sd","off_aug")]


res <- res %>% group_by(pilot_size, off_aug) %>%
  summarise(
    Mean = mean(ks_mean),
    Sd = mean(ks_sd)
  )

res <- tidyr::pivot_longer(res, cols = c("Mean", "Sd"), names_to = "Metric", values_to = "Rate")
res$pilot_size <- factor(res$pilot_size, levels = c("20", "30", "40", "50", "60", "70"))
res$Metric <- factor(res$Metric, levels = rev(c("Mean", "Sd")))
res$text <- round(res$Rate,3)
res$text[is.na(res$Rate)] <- "NA"
res$Rate[is.na(res$Rate)] <- 3
ggplot(res,aes(x = pilot_size , y = Metric, fill = Rate),) + 
  geom_tile(show.legend = T)+
  labs(fill = "MAD")+
  labs(y="",x="")+
  facet_wrap(vars(off_aug),dir="v")+
  geom_text(aes(pilot_size, Metric, label = text), color = "black", size = 4) +
  theme_minimal()+
  scale_fill_gradientn(colours = terrain.colors(10))+
  theme(axis.text.y = element_text(angle = 0, hjust = 1, colour = "black",size = 10))+
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_blank())+
  theme(legend.position = "bottom")+
  scale_y_discrete(labels=c( "Sd" = "SD",
                            "Mean" = "Mean"))


save(df_acc_aug, file = "ResAug/ACCPositive_12_dfres_offaug_VAE1-100.RData")
```
